\documentclass[a4paper, 12pt, titlepage]{extarticle}
  \usepackage{cmap}
  \usepackage[hidelinks,pdftex,unicode]{hyperref}
  \usepackage{mathtext} % для кириллицы в формулах
  \usepackage[T2A]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage[english,russian]{babel}
  \usepackage{indentfirst}
  \usepackage{cite}
  \usepackage{amsmath} % для \eqref
  \usepackage{amssymb} % для \leqslant
  \usepackage{amsthm} % для \pushQED
  \usepackage{color} % пока только для TODO:
  \usepackage[pdftex]{graphicx}
  \usepackage{subfig}
  \usepackage{numprint}
  \usepackage[left=3cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
  \usepackage{datetime}
  \graphicspath{{../img/}{../../img/}}
  \frenchspacing

  \DeclareSymbolFont{T2Aletters}{T2A}{cmr}{m}{it} % кириллица в формулах курсивом

  %\addto\captionsrussian{
    %\renewcommand\contentsname{Содержание}
    % перекрываю \refname, чтобы список литературы сам добавлял себя в оглавление
    \let\oldrefname\refname
    \renewcommand\refname{\addcontentsline{toc}{section}{\oldrefname}\oldrefname}
  %}

  \newcommand{\underscore}[1]{\hbox to#1{\hrulefill}}
  \newcommand{\todo}[1]{\textbf{\textcolor{red}{TODO: #1}}}
  \newcommand{\note}[1]{\textit{Note: #1}}
  \newcommand{\eng}[1]{#1}
  \newcommand{\rus}[1]{{\Russian #1}}

  \newenvironment{original}{%
     \itshape
     \color{blue}
     \Russian
  }{}

  % обёртка с моими настройками поверх figure:
  % \begin{myfigure}{подпись}{fig:label} ... \end{myfigure}
  \newenvironment{myfigure}[2]%
    {\pushQED{\caption{#1} \label{#2}} % push caption & label
     \begin{figure}[!htb]\centering } %
    {  \popQED % pop caption & label
     \end{figure}}

  % вставка картинки: \figure[params]{подпись}{file}
  % создаёт label вида fig:file
  \newcommand{\includefigure}[3][]{
    \begin{myfigure}{#2}{fig:#3}
      \includegraphics[#1]{#3}
    \end{myfigure}
  }

  % вставка subfigure внутри myfigure:
  % \subfigure[params]{подпись}{file}
  \newcommand{\subfigure}[3][]{
    \subfloat[#2]{\label{fig:#3}\includegraphics[#1]{#3}}
  }

  \newcommand{\vect}[1]{\mathbf{#1}} % единое выделение векторов (полужирным)
  \newcommand{\matx}[1]{\mathbf{#1}} % единое выделение матриц (полужирным)
  \newcommand{\transposed}{\top} % единый знак транспонирования (U+22A4 down tack)
  % \renewcommand{\le}{\leqslant} % <= с наклонной нижней перекладиной
  % \renewcommand{\ge}{\geqslant} % >= с наклонной нижней перекладиной

  \linespread{1.0}

  % русские буквы для списков и частей рисунка
  %\renewcommand{\theenumii}{(\asbuk{enumii})}
  %\renewcommand{\labelenumii}{\asbuk{enumii})}
  %\renewcommand{\thesubfigure}{\asbuk{subfigure}}

  %\let\oldsection\section
  %\renewcommand{\section}{\newpage\oldsection}

  \setcounter{tocdepth}{3} % глубина оглавления

  \bibliographystyle{unsrt}

  \hyphenation{англ} % убрать перенос в этом сокращении

  % алиас и настройки для numprint
  \newcommand{\num}[1]{\numprint{#1}}
  \npthousandsep{\,}
  \npthousandthpartsep{}
  \npdecimalsign{,}

  \newcommand{\checkdate}[3]{({accessed at: \formatdate{#1}{#2}{#3}})}

  \newenvironment{firstpage}%
    {\thispagestyle{empty} \begin{center} \large}
    {\end{center} \newpage}

  \author{Ivan Novikov, NSU Physics Department, group 7355}
  \title{A system for modeling plastic deformations of body in real-time}

\begin{document}

%----------------------- титульный лист ------------------------

  \begin{firstpage}
  MINISTRY OF EDUCATION AND SCIENCE

  RUSSIAN FEDERATION

  \vspace{0.3cm}

  NOVOSIBIRSK STATE UNIVERSITY

  \vspace{1.6cm}

  PHYSICS DEPARTMENT

  \vspace {0.5cm}

  AUTOMATION OF PHYSICS AND TECHNICAL RESEARCH CHAIR

  \vspace {5cm}

  Qualification Work on Bachelor Degree

  \vspace {1cm}

  Ivan Novikov, group 7355

  \vspace {1.5cm}

  \textbf{A system for modeling plastic deformations of body in real-time}

  \vspace {1.5cm}

  \begin{flushright}

    Scientific Advisor:

    Dennis Gladky

  \end{flushright}

  \vspace {6cm}

  Novosibirsk 2012
  \end{firstpage}

%------------------------- содержание -------------------------

  \tableofcontents
  \newpage
  \setlength{\parskip}{1ex}

%-------------------------- введение --------------------------
  \section{Introduction}

    \begin{original}
    Приложения виртуальной реальности становятся чрезвычайно рас\-прос\-тра\-нён\-ны\-ми в~наши~дни.  Два
    основных их типа~--- это компьютерные игры и~обучающие симуляторы (тренажёры). Несмотря на
    различные применения, эти два типа приложений имеют много общего, поскольку в~обоих случаях
    требуется создать иллюзию присутствия у~пользователя. Для~этого необходимо как генерировать
    фотореалистичные изображения, так и правдоподобно моделировать физику взаимодействия объектов
    виртуального мира: их движение, столкновения, деформации и~разрушение.
    \end{original}

    Virtual reality applications become extremely wide-spread nowadays. Two basic types of such
    applications are computer games and training simulators. Despite of different uses, this two
    types of applications have a lot in common, because in both cases it is necessary to create
    illusion of presence. It requires not only to generate photo-realistic images, but also model
    interactions of virtual world objects (their motion, collisions, deformations and destruction)
    in a verisimilar manner.

    \begin{original}
    Моделирование деформаций объектов является актуальной задачей, поскольку кроме приложений
    виртуальной реальности оно находит применение в~системах автоматизированного проектирования, а~также используется
    при~создании спецэффектов к~фильмам. В зависимости от поставленной задачи применяются различные
    подходы. А~именно, в~системах автоматизированного проектирования требуется
    максимальная точность расчётов, в~то~время как в~фильмах и приложениях виртуальной реальности
    требуется лишь визуальная правдоподобность. При~этом, если расчёты для САПР и~спецэффектов могут
    выполняться длительное время, то в~интерактивных приложениях расчёт одного шага вычислений должен
    происходить не~дольше, чем за~промежуток между кадрами, чтобы обеспечивать плавную анимацию
    и отсутствие задержек между воздействием на объект и его деформацией.
    \end{original}

    Modeling deformations is a topical problem, since besides virtual reality applications it is
    applied in Computer Aided Design (CAD) systems and for making special effects for motion
    pictures.  Different approaches can be applied depending on task. Namely, CAD systems require
    maximal accuracy of computation, while for films and virtual reality visual plausibility is
    enough. Moreover, while % repetition of while (?)
    computation for CAD software and special effects may take a long time, a~step of computation in in interactive
    applications should take no longer than inter-frame interval to ensure smooth animation and
    eliminate lags between interaction with an object and its deformation.

    \begin{original}
    Жёсткое требование быстродействия в приложениях реального времени не~только вынуждает
    использовать упрощённые физические модели деформации тела, менее точные, чем используемые
    в~инженерных расчётах, но и накладывают существенные ограничения на способ представления
    моделируемого объекта. Чаще всего он задаётся дискретным образом: в~виде сетки, решётки или
    несвязанного набора точек, причём время расчётов напрямую (как~правило, линейно
    \cite{mueller-meshless}) зависит от количества точек в таком представлении. Для отображения
    объектов обычно используют высоко детализированные сетки, содержащие вплоть до нескольких
    сотен тысяч и даже миллионов точек. Это значительно превышает максимальное допустимое число точек для~большинства
    алгоритмов \cite{mueller-stable, mueller-meshless, chang-crash} при расчётах в~реальном времени на
    современных настольных компьютерах и компьютерах, используемых в тренажёрах. Из-за этого
    невозможно использовать одно и~то~же представление объекта и для моделирования, и для
    отображения.
    \end{original}

    Severe performance requirements of virtual reality applications not only makes developers use
    simplified physical models of deformations, but also significantly limits the way of
    representation of modelled objects. Usually it is represented in a discrete way: as a mesh, a
    grid or a set of unconnected points. The time of computations is directly related (typically,
    linearly \cite{mueller-meshless}) to the number of points in such representation.
    Highly-detailed meshes of hundreds of thousands and even millions of points are commonly used
    for displaying detailed objects, which is far beyond maximum possible number of points for most
    real-time algorithms \cite{mueller-stable, mueller-meshless, chang-crash} if they are applied on
    usual modern personal computers. So it becomes impossible to use the same representation for
    both modeling and displaying of an object.


  \section{Overview of the subject area}\label{sec:domain}

    \begin{original}
    Существуют различные подходы к~моделированию деформаций в~реальном времени. В простейшем случае
    ограничения на~быстродействие алгоритма обходятся за счёт использования предварительно рассчитанных
    деформированных состояний для~некоторого конечного набора возможных ударов по~объекту, одно из которых
    (или~интерполяция между несколькими ближайшими) выбирается в~зависимости от~того, к~какому
    из~этих ударов ближе всего произошедший. В~этом случае допускается использование достаточно сложных
    для~вычисления алгоритмов, таких~как система масс и~пружин (англ. \eng{mass-spring system})
    с~большим разрешением или~метод конечных элементов (англ. \eng{finite elements method, FEM}).
    Однако, при ударе, отличающемся от~заранее рассчитанного, или в~случае сложной комбинации ударов
    моделируемые деформации будут выглядеть не реалистично \cite[раздел~2]{chang-crash}. Кроме того, значительное время, требуемое
    для предварительных расчётов после каждого изменения объекта, прежде чем он может быть загружен
    в приложение для тестирования, создаёт неудобства при разработке приложения. Поэтому наибольший
    интерес представляют решения, в которых моделирование деформаций происходит во время исполнения.
    \end{original}

    There are different approaches to modeling of deformations in real-time. In the simplest case
    performance limitations can be left out by using precomputed deformed states for some limited
    set of predefined strokes. In real-time, one of these precomputed states (or an interpolation
    between several nearest ones) is chosen depending on which predefined stroke is the most similar
    to happened one. In this case using relatively complex algorithms is allowed, such as
    mass-spring system with high resolution or finite elements method. However, if happened stroke
    differs from predefined ones a lot, or if some complicated combination of strokes takes place,
    then simulated deformation will look unrealistic \cite[section~2]{chang-crash}. Furthermore,
    considerable time required for preliminary computations creates inconveniences in the process of
    development. So the algorithms of simulating deformations at run-time are of the most interest.

    \begin{original}
    Одной из~простейших моделей деформируемого тела является упоминавшаяся выше система масс
    и~пружин, в~которой тело представляется в~виде пространственной (как~правило, регулярной и
    кубической) решётки из~материальных точек, которые связаны между~собой пружинами, при~изменении длины
    прикладывающими к~своим концам силу согласно закону Гука. Будучи очень простой в~реализации,
    такая модель, тем не менее, имеет определённые недостатки. Она моделирует поведение объекта не
    очень точно, причём результат сильно зависит от формы решётки и расположения пружин в ней, а так же от
    значений коэффициента упругости каждой отдельной пружины, которые напрямую не связаны с
    реальными свойствами моделируемого материала \cite[п.~3.5.2]{mueller-physmodels}.
    Другим недостатком является то, что возбуждение, приложенное локально, распространяется по
    объекту постепенно, перемещаясь на один шаг решётки за шаг алгоритма \cite[п.~4.4.1]{parent-animation}.
    Кроме~того, требуется выполнять дополнительную работу по конвертации представления объекта,
    используемого для его отображения (чаще всего это неравномерная поверхностная сетка из
    треугольников), в~равномерную объёмную решётку, а также подбирать большое число значений
    коэффициентов упругости пружин так, чтобы добиться требуемых свойств моделируемого материала.
    \end{original}

    One of the most simple models of deformable body is the aforementioned mass-spring system, in
    which a body is represented as dimensional (usually, regular and cubical) grid of mass points,
    which are connected with springs, acting according to Hooke's law. Being very simple for
    implementation, this model, however, has some certain drawbacks. It models object behaviour not
    very precise, and the result depends significantly on the grid shape and spring locations, as well as on
    spring constant values of each particular spring, which are not connected directly with real
    properties of modeled material \cite[sec. 3.5.2]{mueller-physmodels}. Another flaw it that an
    excitation applied locally spreads through object slowly, covering one step of the grid at a
    step of the algorithm \cite[sec. 4.4.1]{parent-animation}. Moreover, additional work of converting
    superficial mesh of triangles (a typical representation for 3D objects in software) into regular
    grid and for adjusting spring constants to achieve required properties of modelled material.

    \begin{original}
    Принципиально другой подход реализуется в моделях, использующих метод конечных элементов, широко
    применяемый в~инженерных расчётах. При таком подходе
    непрерывные характеристики деформируемого тела вычисляются путём интерполяции их~значений
    на~элементах конечного размера. Разумеется, использовать в чистом виде этот метод
    в приложениях реального времени невозможно, поскольку инженерные расчёты производятся в
    течение нескольких часов и даже суток. Однако, существуют модели, предлагающие различные упрощения этих
    методов, которые допускают вычисление в реальном времени, как, например, в работе~\cite{mueller-stable}.
    Деформации при этом моделируются намного точнее, чем в случае системы масс и пружин, но даже
    упрощённый алгоритм требует больше времени для вычислений. % TODO циферки
    \end{original}

    Fundamentally different approach is implemented in the models that use Finite Element Method
    which is widely applied for engineering calculations. In this approach continuous parameters of
    deformable body are found by interpolation of their values over the elements of finite size.
    Naturally, this method cannot be used as it is in virtual reality applications, because
    engineering calculations may last some hours or even days. However, the models exist which
    propose different simplifications of this method, making real-time computation possible.
    Deformations are simulated much more precisely than in case of mass-spring systems, but even
    a~simplified algorithm requires more time for computation. The~paper \cite{mueller-stable}
    presents an example of such model.

    \begin{original}
    Отдельно стоят так~называемые геометрические алгоритмы, в~которых напрямую не~моделируются
    физические законы. Как~правило, объект представляется в~виде системы частиц, движение каждой из
    которых сначала интегрируется независимо от~остальных, а~следующим шагом на объект в~целом
    накладываются различные физически мотивированные ограничения (сохранение формы, объёма, импульса
    и~т.п.), обеспечивающие в итоге правдоподобные деформации. Метод сопоставления формы, один из
    таких геометрических методов, описывается в работе~\cite{mueller-meshless}. Он имеет хорошее быстродействие,
    при этом обладая большей устойчивостью и простотой в конфигурации, чем системы масс и пружин.
    \end{original}

    The separate group of methods are formed by so called geometric algorithms. They do not simulate
    laws of physics directly. Generally, the object is represented as a particle system, where
    the movement of each particle is integrated regardless of the others first. At the next step
    different physically motivated restrictions are applied to the entire object, such as
    conservation of shape, volume, momentum etc. They make resulting deformation plausible. Shape
    matching method \cite{mueller-meshless} is one of many geometric algorithms. It has a good
    performance while being more stable and configurable than a mass-spring system.

  \section{Problem statement}\label{sec:task}

    \begin{original}
    Целью работы является разработка системы моделирования деформаций объектов для применения в
    приложениях виртуальной реальности: в компьютерных играх и обучающих тренажёрах.
    К~системе предъявляются следующие требования.
    \end{original}

    The goal of this work is development of the system for modeling deformation of bodies to be
    applied in virtual reality applications: computer games and training simulators.
    Following requirements should be met.

    \subsection{Requirements}

    \begin{original}
    Необходимо использовать сетки из треугольников в качестве внутреннего представления, либо
    предоставить возможность конвертации, поскольку в приложениях виртуальной реальности отображаемые объекты
    чаще всего представляются именно в таком формате. Это связано с~тем, что треугольник является
    одним их основных геометрических примитивов для графических процессоров.~\cite{nvidia-tutorial}
    \end{original}

    Triangle meshes should be used as internal representation, or the possibility of conversion from
    such format should be available, because it is a common way of representing visible objects in
    virtual reality applications. That is because triangle is one of the basic geometric primitives
    for graphical processors~\cite{nvidia-tutorial}.

    \begin{original}
    Система должна иметь достаточное быстродействие, чтобы обеспечивать моделирование в~реальном
    времени. Известно, что для комфорта пользователя и ощущения им реалистичности моделируемого мира
    приложение виртуальной реальности должно обеспечивать кадровую частоту около 30 кадров в секунду %TODO: кадровую-кадров
    и выше~\cite{claypool-framerate}. Следовательно, все расчёты, необходимые для получения
    следующего кадра, в таком приложения должны занимать не более 33 мс. Поскольку расчёт глобального
    движения и трёхмерной графики обычно является более приоритетной задачей, на вычисление
    деформаций отводится небольшая часть этого времени, около 3-5 мс. Чтобы такое быстрое
    моделирование было возможно даже для~объектов, заданных сеткой с~большим числом вершин,
    должна иметься возможность использовать при~моделировании менее детализированное представление
    объекта, а~отображаемую сетку более высокого разрешения обновлять так, чтобы она повторяла
    рассчитанные деформации. % TODO (В дальнейшую работу?) При~этом важно предусмотреть некоторое сглаживание смещений точек
    % отображаемого объекта, иначе в~их~движении можно будет проследить форму низко детализированного
    % представления.
    \end{original}

    The system should be fast enough to provide real-time simulation. A frame rate of 30 frames per
    second or higher is required for user's comfort and feeling of realism of the simulated
    world~\cite{claypool-framerate}. Therefore, all computations necessary for getting the next
    frame should take less than 33~ms. Since global motion and 3D-graphics are usually of
    higher priority than deformations, only a little fraction of this time span is given for
    simulating deformations, about 3-5~ms. To make this fast simulation possible even for objects
    defined as a mesh with lots of vertices, there should be a possibility to use less detailed
    representation of the object for simulation. Displayed mesh of higher resolution in this case
    should only be updated to make it repeat already calculated deformation.

    \begin{original}
    Для эффективного использования вычислительной мощности многоядерных центральных процессоров,
    получающих в наши дни всё большее распространение~\cite{steam-hardware}, нужно, чтобы вычисления могли
    выполняться параллельно.
    \end{original}

    Multi-core central processors become more and more widespread nowadays~\cite{steam-hardware}. In
    order to effectively exploit computational power of such processors the computations should be
    able to run in parallel.

    \begin{original}
    Кроме~того, предварительно рассчитанные деформированные состояния не~должны использоваться,
    поскольку, как было объяснено в разделе~\ref{sec:domain}, такой подход негативно сказывается на реалистичности
    моделирования и создаёт неудобства при разработке приложения.
    \end{original}

    In addition, precomputed deformable states should no be used, because this approach adversely
    affects the realism of simulation and creates inconveniences during the development process, as
    it was explained in section~\ref{sec:domain}.

    \begin{original}
    Наконец, интерфейс, предоставляемый системой, не~должен создавать трудностей при её интеграции
    в~приложения виртуальной реальности. Основные критерии, которым необходимо следовать,
    описаны в~\cite{gems-middleware} и~включают, в~частности, конфигурируемые обработку ошибок,
    журналирование и~выделение памяти, а также отказ от~прямого доступа к~файловой системе в~пользу
    работы с~буферами в~оперативной памяти. Кроме того, нельзя допускать зависимости от конкретных
    реализаций примитивов синхронизации и функций для работы с потоками, поскольку это может создать
    неудобства, если в приложении используются другие реализации.
    \end{original}

    Finally, the interface of the system should not create difficulties during its integration into
    virtual reality applications. The application which the system is integrated into is further called
    the \emph{host application}. The basic criteria to be followed are described in~\cite{gems-middleware}.
    They include, in particular, configurable error handling, logging and memory management, as well
    as refusing from direct access to file systems in favour of working with in-memory buffers.
    Moreover, dependence on specific implementations of synchronization primitives and thread
    manipulation functions should not be allowed, because it might create problems if the
    application uses different implementation.

    \subsection{Objectives}

    \begin{original}
    Для достижения цели необходимо решить следующие задачи:
    \begin{enumerate}
      \item Разработать и~реализовать алгоритм моделирования в реальном времени деформаций
        не\-у\-пру\-гих тел, содержащих недеформируемые части.
      \item Предоставить интерфейс для~двустороннего взаимодействия с~приложением, в~которое будет
        встроена система, включающий:
        \begin{enumerate}
          \item конвертацию представления объекта, используемого в приложении, во внутреннее представление;
          \item получение извне информации о~столкновениях объекта и~приложенных к~нему силах;
          \item уведомление о событиях, произошедших в процессе деформации;
          \item обновление отображаемой сетки.
        \end{enumerate}
      \item Предусмотреть возможность использования параллельных вычислений.
    \end{enumerate}
    \end{original}

    In order to achieve the goal of this work the following objectives should be completed:
    \begin{enumerate}
      \item To develop and implement the algorithm for modelling plastic deformations of bodies
        containing undeformable parts.
      \item To implement the interface of two-way communication with the application the system will
        embedded into, including:
        \begin{enumerate}
          \item conversion of the object representation used in the application into internal representation;
          \item obtaining the information about collisions with the object and the forces applied to it;
          \item notifying the application about the events happened during deformation
          \item updating the displayed mesh.
        \end{enumerate}
      \item To provide support for using parallel computing.
    \end{enumerate}

  \section{Modeling deformation}

    \begin{original}
    В этом разделе рассматриваются методы, используемые для решения поставленных задач. Описан выбор
    основного алгоритма для моделирования деформаций неупругих тел, сделанные в~нём изменения,
    а~также реализация дополнительных функций и применение параллельных вычислений.
    \end{original}

    In this section the methods are considered which are used for solving the stated problem. Described are
    the main algorithm chosen for modeling plastic deformations of bodies, the improvements that were
    made to it, as well as the implementation of additional features and the use of parallel computing.

    \subsection{Basic algorithm}\label{ssec:basic_algorithm}

      \begin{original}
      В разделе~\ref{sec:domain} были рассмотрены различные подходы к моделированию деформаций:
      система масс и пружин, упрощённый метод конечных элементов и геометрический метод
      сопоставления формы. В~частности, было показано, что использование системы масс и пружин
      связано с~необходимостью существенного преобразования формата объекта и подбора большого числа
      коэффициентов, напрямую не определяемых свойствами материала. Упрощённый метод конечных
      элементов, в свою очередь, оперирует реальными непрерывными характеристиками материала, и
      за~счёт этого моделирует деформации очень реалистично, но имеет плохое быстродействие. Поэтому
      в~данной работе выбор был сделан в пользу метода сопоставления формы, предложенного в
      работе~\cite{mueller-meshless}. Он работает значительно быстрее, но, чтобы моделирование было
      реалистичным, нужно в каждом конкретном случае правильно подобрать параметры. Впрочем, число
      этих параметров меньше, чем в случае метода масс и пружин. Далее описан исходный алгоритм и
      изменения, которые были сделаны для его адаптации к текущей задаче.
      \end{original}

      In the section~\ref{sec:domain} different approaches to modelling deformations were
      considered. They include a~mass-spring system, a~simplified finite elements method and
      a~geometric method of shape matching. In particular, it was shown that using mass-spring
      systems is concerned with the need for considerable transformation of object format and for
      selection of many coefficients which are not derived directly from the properties of the
      modelled material. A simplified finite element method, on the contrary, operates real
      continuous properties of the material and thus simulates deformations in a very realistic way,
      but it is not fast enough. That is why in this work the choice was made in favor of shape
      matching method proposed in~\cite{mueller-meshless}. It works much faster but in order to make
      simulation realistic it is necessary to correctly adjust parameters for each particular case.
      Nevertheless, the number of these parameters is less than in case of a mass-spring system.
      Described below are the original algorithm of shape matching and the changes made to adapt it
      for current task.

      \subsubsection{Original algorithm}\label{sssec:original_algorithm}

        \begin{original}
        \paragraph{Входные данные и результат.} Объект представляется в~виде набора точек,
        сгруппированных в~перекрывающиеся множества, называемые кластерами
        (информация о~связях между вершинами, то~есть об~образуемых ими полигонах, не требуется).
        На~вход алгоритма поступает заданный таким образом объект, а так же информация о~приложенных
        силах. Задаётся величина шага по времени. Результатом выполнения одной итерации алгоритма
        являются позиции точек, задающих объект, в следующий момент времени.
        \end{original}

        \paragraph{Input and output.} An object is represented by an array of points, grouped into
        overlapping sets here called clusters. Therefore, the information about connections between
        vertices is not required. An object represented this way is given to the algorithm as the
        input, as well as the information about applied forces. Time step value is set. The results
        of single iteration of algorithm are positions of points representing object at the next
        instant of time.

        \begin{original}
        \paragraph{Общая схема алгоритма.} Скорости и позиции этих материальных точек интегрируются независимо
        друг от друга, для чего используется явная схема Эйлера. Затем над каждым кластером
        производится операция сопоставления формы: вычисляется новое положение центра масс кластера
        и оптимальное линейное преобразование $\matx A$, действие которого переводит исходную форму
        кластера в~наиболее близкую к~текущей форме. Пусть $\vect{x}^0_i$ и $\vect{x}_i$~---
        соответственно исходная и текущая позиция $i$-й точки,
        $\vect{x}^0_{ц.м.}$ и $\vect{x}_{ц.м.}$~--- исходный и текущий центр масс кластера. Введём
        $\vect{q}_i = \vect{x}^0_i - \vect{x}^0_{ц.м.}$,
        $\vect{p}_i = \vect{x}_i - \vect{x}_{ц.м.}$~--- исходное и текущее положение точки
        относительно центра масс кластера. Эти относительные позиции и будут сравниваться при
        сопоставлении формы. В качестве критерия оптимальности для преобразования $\matx A$
        используется сумма квадратов отклонений начальных позиций, преобразованных его действием, от текущих:
        $\sum_i m_i (\matx A \vect{q}_i - \vect{p}_i )^2$. В работе~\cite{mueller-meshless} было
        показано, что эта величины достигает минимума, если
        \begin{equation}
          \matx A = \left( \sum_i m_i \vect{p}_i \vect{q}_i^\transposed \right)
                    \left( \sum_i m_i \vect{q}_i \vect{q}_i^\transposed \right)^{-1}.
        \end{equation}
        \end{original}

        \paragraph{General scheme of the algorithm.} Velocities and positions of these mass-points
        are integrated regardless of each other using explicit Euler method. Then each cluster is
        subjected to shape matching operation: a new position of the center of mass of the cluster
        is found, as well as an optimal linear transformation $\matx A$ which converts the initial
        shape of the cluster into the closest to the current shape. Let $\vect{x}^0_i$ and
        $\vect{x}_i$ be the initial and the current position of $i^{th}$ point, $\vect{x}^0_{c.m.}$
        and $\vect{x}_{c.m.}$ be the initial and the current center of mass of the cluster. By
        $\vect{q}_i = \vect{x}^0_i - \vect{x}^0_{c.m.}$ and $\vect{p}_i = \vect{x}_i -
        \vect{x}_{c.m.}$ denote the initial and the current offset of point relative to the center
        of mass of the cluster. As a criteria of optimality for the transformation $\matx A$ used is
        the sum of squared differences between transformed initial positions and current positions:
        $\sum_i m_i (\matx A \vect{q}_i - \vect{p}_i )^2$. It was shown in~\cite{mueller-meshless}
        that this term is maximized when
        \begin{equation}
          \matx A = \left( \sum_i m_i \vect{p}_i \vect{q}_i^\transposed \right)
                    \left( \sum_i m_i \vect{q}_i \vect{q}_i^\transposed \right)^{-1}.
        \end{equation}

        \begin{original}
        После того как оптимальное преобразование $\matx A$ найдено, для каждой точки определяется
        положение, которое она имела бы, если бы изменение формы кластера в~точности определялось этим
        преобразованием, с~учётом смещения центра масс:
        \begin{equation}
          \vect{g}_i = \matx{A} (\vect{x}^0_i - \vect{x}^0_{ц.м.}) + \vect{x}_{ц.м.}.
        \end{equation}
        \end{original}

        Once the optimal transformation $\matx A$ of the cluster is found, the goal position is
        calculated for each point which belongs to it. The \emph{goal position} of a point is a
        position which it would have if the change of cluster's shape was defined exactly by the
        transformation $\matx A$. The change of the center of mass is also taken into account:
        \begin{equation}
          \vect{g}_i = \matx{A} (\vect{x}^0_i - \vect{x}^0_{c.m.}) + \vect{x}_{c.m.}.
        \end{equation}

        \begin{original}
        Далее $\vect{g}_i$ называется целевой позицией точки. Для каждой точки, исходя из величины
        отклонения её текущей позиции от~целевой, рассчитывается поправка к~скорости, корректирующая
        это отклонение. Если точка входит одновременно в~несколько кластеров, то~есть находится
        в~зоне их перекрытия, корректирующие поправки от~каждого из~кластеров усредняются, что
        обеспечивает целостность объекта: за~счёт этого кластеры, обрабатываемые независимо,
        не~отделяются друг от~друга.
        \end{original}

        For each point of the cluster an amendment to its velocity is calculated which corrects the
        deviation of the current position from the goal position. If the point is included in more
        than one cluster (that is, belongs to their intersection) then the amendments from different
        clusters are averaged. This ensures integrity of the object: due to that fact the clusters
        do not separate from each other although they are handled independently.

        \begin{original}
        \paragraph{Остаточная деформация.} Для моделирования неупругости остаточная деформация
        каждого кластера сохраняется в~форме линейного преобразования $\matx{S}^{ост}$, то~есть
        матрицы $3 \times 3$. Изначально она единичная, а~изменение происходит, лишь когда мера
        текущей деформации превышает заданную пороговую величину $d_{неупр}$. В~качестве такой меры может быть
        использована $ \|\matx S - \matx E\|_2 $, где $\matx S$~--- симметричная компонента $\matx
        A$, $\matx E$~--- единичная матрица, норма Фробениуса $\|\matx M\|_2 = \sqrt{\sum_{i, j} |m_{ij}|^2}$.
        Симметричная матрица $\matx S$ получается при полярном разложении матрицы $\matx A$:
        \begin{equation}
          \matx A = \matx R \matx S,
        \end{equation}
        где $\matx R$~--- ортогональная матрица. Выбор именно симметричной компоненты обусловлен
        тем, что в неё не входят вращения, которые не изменят форму и потому не должны учитываться.
        Когда описанная мера превышает $d_{неупр}$, матрица $\matx{S}^{ост}$ должна измениться,
        сохранив часть текущей деформации:
        \begin{equation}
          \matx{S}^{ост} = \left(E + u \Delta t (\matx S - \matx E) \right) \matx{S}^{ост},
        \end{equation}
        здесь $\Delta t$~--- шаг по времени, а параметр $u$ характеризует скорость изменения
        остаточной деформации. Максимальная остаточная деформация ограничена: когда
        $\|\matx{S}^{ост} - \matx E\|_2$ достигает предельной величины $d_{max}$, матрица
        $\matx{S}^{ост}$ перестаёт изменяться. Остаточная деформация учитывается затем при
        сопоставлении формы и расчёте целевых позиций. А именно, исходные позиции перед сравнением
        с текущими при сопоставлении формы, преобразуются матрицей $\matx{S}^{ост}$. Таким
        образом, сопоставление происходит не с~исходной, а с деформированной формой. Кроме того, формула для
        расчёта целевых позиций принимает следующий вид:
        \begin{equation}
          \vect{g}_i = \matx{A} \matx{S}^{ост} (\vect{x}^0_i - \vect{x}^0_{ц.м.}) + \vect{x}_{ц.м.}.
        \end{equation}
        \end{original}

        \paragraph{Residual deformation.} To simulate inelasticity the residual deformation of each
        cluster is saved in the form of a linear transformation $\matx{S,}^{\!\!res}$ that is, in the
        form of a $3 \times 3$ matrix. Initially, it is a unity matrix and it is changed only when
        the measure of deformation exceeds a predefined threshold value $d_{inelast}$. A possible
        measure of deformation is $ \|\matx S - \matx E\|_2 $, where $\matx S$ is a symmetric
        component of $\matx A$, $\matx E$ is a unity matrix, and the matrix norm is the Frobenius
        norm which is defined as follows: $\|\matx M\|_2 = \sqrt{\sum_{i, j} |m_{ij}|^2}$. The
        symmetric matrix $\matx S$ is obtained via polar decomposition of the matrix $\matx A$:
        \begin{equation}\label{eq:polar_decomposition}
          \matx A = \matx R \matx S,
        \end{equation}
        where $\matx R$ is an orthogonal matrix. The choice of symmetric component is determined by
        the fact that it doesn't include rotations. Rotations doesn't change shape and thus should
        not be considered in the measure of deformation. When the described measure exceeds $d_{inelast}$
        the matrix $\matx{S}^{res}$ should update in order to save a portion of current deformation:
        \begin{equation}
          \matx{S}^{res} = \left(E + u \Delta t (\matx S - \matx E) \right) \matx{S}^{res}.
        \end{equation}
        Here $\Delta t$ is a time step, and the parameter $u$ describes how fast residual
        deformation is changed. Maximum residual deformation is limited: when
        $\|\matx{S}^{res} - \matx E\|_2$ reaches extreme value of $d_{max}$ the matrix
        $\matx{S}^{res}$ ceases to change. Residual deformation is then taken into account during
        shape matching and computing goal positions. To be exact, initial positions are transformed
        by the matrix $\matx{S}^{res}$ before they are compared to current positions. Thus,
        matching is made to deformed shape instead of the initial one. Besides, the formula for goal
        positions becomes as follows:
        \begin{equation}\label{eq:goal_pos}
          \vect{g}_i = \matx{A} \matx{S}^{res} (\vect{x}^0_i - \vect{x}^0_{c.m.}) + \vect{x}_{c.m.}.
        \end{equation}

      \subsubsection{Proposed changes of algorithm}\label{sssec:proposed_changes}

        \begin{original}
        В~исходный алгоритм вносятся изменения, адаптирующие его к~условиям данной
        задачи. Во-первых, моделирование неупругих тел требует демпфирования возникающих колебаний.
        Во-вторых, система отвечает только за~моделирование деформаций, а глобальное движение и
        определение столкновений рассчитываются отдельно приложением, в~которое встроена система.
        Поэтому расчёт деформаций необходимо производить в~локальных координатах~---
        в~неинерциальной системе отсчёта, связанной с центром масс объекта, в которой он не
        движется и не вращается. Далее для краткости она называется системой центра масс.
        \end{original}

        The changes are made to the basic algorithm in order to adapt it to the current conditions.
        First, simulation of inelastic bodies requires damping of arising oscillations. Second, the
        system is responsible for modeling only deformations, while global motion and collision
        detection are computed separately in the host application. Consequently, the computation of
        deformations should be made in local coordinates: in a non-inertial reference frame
        associated with the center of mass of the object where it neither move or rotate. Further
        this reference frame is called the \emph{center-of-momentum frame.}

        \begin{original}
        \paragraph{Демпфирование.} Чтобы поведение неупругого тела выглядело правдоподобно,
        нужно, чтобы затухали только колебания, а глобальное движение тела сохраняло свои характеристики.
        Для этого используется способ, описанный в~\cite[подраздел~3.5]{mueller-position-dynamics}. Сначала выделяется
        движение тела как~целого~--- вычисляются скорость центра масс $\vect{v}_{ц.м.}$ и угловая
        скорость $\vect{\omega}$. Для этого находятся центр масс
        $\vect{x}_{ц.м.}$ и тензор инерции $\matx I$ (матрица $3 \times 3$):
        \begin{eqnarray*}
          \vect{x}_{ц.м.} & = & \frac{\sum_i m_i \vect{x_i}}{\sum_i m_i},\\
          \vect{r}_i      & = & \vect{x}_i - \vect{x}_{ц.м.},\\
          \matx{I}        & = & \sum_i m_i ( |\vect{r}_i|^2 \matx E - \vect{r}_i \vect{r}_i^\transposed),\\
        \end{eqnarray*}
        где $\matx E$~--- единичная матрица $3 \times 3$. Затем вычисляются
        \begin{eqnarray*}
          \vect{v}_{ц.м.} & = & \frac{\sum_i m_i \vect{v_i}}{\sum_i m_i},\\
          \vect{L}        & = & \sum_i \vect{r}_i \times (m_i \vect{v}_i),\\
          \vect{\omega}   & = & \matx{I}^{-1} \vect{L}.
        \end{eqnarray*}
        Для каждой вершины определяется скорость,
        которую она имела~бы, если~бы тело было абсолютно твёрдым:
        \begin{equation}
          \vect{u}_i = v_{ц.м.} + \omega \times (\vect{x}_i - \vect{x}_{ц.м.}).
        \end{equation}
        Демпфированию подвергается только индивидуальное отклонение скорости вершины
        $\Delta \vect{v}_i = \vect{v}_i - \vect{u}_i$:
        \begin{equation}
          \vect{v}_i = \vect{v}_i - k \Delta \vect{v}_i,
        \end{equation}
        где $k \in [0, 1]$. За счёт этого $\vect{v}_{ц.м.}$ и $\vect{\omega}$ сохраняются.
        \end{original}

        \paragraph{Damping.}
        In order that the behavior of inelastic body looks plausible it is necessary that only
        oscillations are damped while global motion conserves its parameters. For that used is the
        method described in~\cite[sec.~3.5]{mueller-position-dynamics}. At first the motion of the
        body as a whole is singled out: the velocity of the center of mass $\vect{v}_{c.m}$ and the
        angular velocity $\vect{\omega}$ are computed. In order to do this the center of mass and
        the moment of inertia tensor $\matx I$ (a $3 \times 3$ matrix) are found:
        \begin{eqnarray*}
          \vect{x}_{c.m.} & = & \frac{\sum_i m_i \vect{x_i}}{\sum_i m_i},\\
          \vect{r}_i      & = & \vect{x}_i - \vect{x}_{c.m.},\\
          \matx{I}        & = & \sum_i m_i ( |\vect{r}_i|^2 \matx E - \vect{r}_i \vect{r}_i^\transposed),\\
        \end{eqnarray*}
        where $\matx E$ is a $3 \times 3$ unity matrix. Then the mentioned velocities are computed:
        \begin{eqnarray*}
          \vect{v}_{c.m.} & = & \frac{\sum_i m_i \vect{v_i}}{\sum_i m_i},\\
          \vect{L}        & = & \sum_i \vect{r}_i \times (m_i \vect{v}_i),\\
          \vect{\omega}   & = & \matx{I}^{-1} \vect{L}.
        \end{eqnarray*}
        For each vertex computed is the velocity which it would have if the body was absolutely rigid:
        \begin{equation}\label{eq:rigid_velocity}
          \vect{u}_i = v_{c.m.} + \omega \times (\vect{x}_i - \vect{x}_{c.m.}).
        \end{equation}
        Only individual deviations of vertex velocity $\Delta \vect{v}_i = \vect{v}_i - \vect{u}_i$
        are subjected to damping:
        \begin{equation}\label{eq:damping}
          \vect{v}_i = \vect{v}_i - k \Delta \vect{v}_i,
        \end{equation}
        where $k \in [0, 1]$. Therefore, $\vect{v}_{c.m.}$ and $\vect{\omega}$ are conserved as necessary.

        \begin{original}
        \paragraph{Расчёт в локальных координатах.} Проблема, возникающая при расчёте деформаций в
        системе центра масс, заключается в том, что вследствие удара или воздействия внешних сил
        у~тела может появиться как ненулевая скорость центра масс, так и ненулевая угловая скорость.
        Таким образом, система отсчёта, в~которой производится расчёт, перестанет быть системой центра
        масс. Поэтому после интегрирования скоростей и до интегрирования позиций вершин производится
        коррекция. Приобретённые на данном шаге $\vect{v}_{ц.м.}$ и $\vect{\omega}$ уже получены
        в~ходе расчёта демпфирования. Чтобы локальная система отсчёта снова стала системой центра масс,
        необходимо скомпенсировать их, вычитая из скорости каждой вершины $\vect{u}_i$ из \eqref{eq:rigid_velocity}.
        После этого приложение, в которое встроена система, должно получить из неё значения
        $\vect{v}_{ц.м.}$ и $\vect{\omega}$ и скорректировать глобальное движение объекта, прибавив их
        к его линейной и угловой скоростям соответственно.
        \end{original}

        \paragraph{Computing in local coordinates.} The problem which appears when deformations are
        computed in the center-of-momentum frame is as following. As a result of a stroke or
        external forces effect, a non-zero velocity of the center of mass of body may appear, as well as
        non-zero angular velocity. Thus, the named reference frame will no longer be the
        center-of-momentum frame. That is why the correction is made after integrating velocities
        and before integrating positions of vertices. $\vect{v}_{c.m.}$ and $\vect{\omega}$ acquired
        during the present step are already calculated during the computation of damping. In order to
        return back to the center-of-momentum frame again it is required to compensate these
        velocities. It is done by subtracting $\vect{u}_i$ defined in \eqref{eq:rigid_velocity} from
        the velocity of $i^{th}$ vertex, consequently for each vertex. After that the host
        application should get the values of $\vect{v}_{c.m.}$ and $\vect{\omega}$ and correct the
        global motion of the object by adding them to its linear and angular velocities, correspondingly.

    \subsection{Implementation of additional features}

      \begin{original}
      Как уже говорилось в разделе~\ref{sec:task}, кроме собственно моделирования деформаций, ядро
      системы предоставляет дополнительную функциональность, а именно, поддержку недеформируемых
      частей, получение информации о произошедших столкновениях и приложенных силах, обнаружение
      определённых событий и обновление отображаемой сетки. Предлагаемые способы
      реализации этих функций описаны далее.
      \end{original}

      As it was already mentioned in section~\ref{sec:task}, the core of the system provides
      an additional functionality besides modelling deformation. This includes support for
      undeformable parts, obtaining information about happened collisions and applied forces,
      detection of certain events and updating the displayed mesh. Proposed means of implementation
      of these functions are described below.

      \subsubsection{Support for undeformable parts}

        \begin{original}
        Имеется возможность задать множество вершин, сохраняющее свою форму~--- недеформируемую раму.
        Чтобы обеспечить это, используется та~же техника, что и в~алгоритме демпфирования,
        описанном в п.~\ref{sssec:proposed_changes}, только коэффициент $k$ в~\eqref{eq:damping}
        берётся равным единице, то~есть индивидуальные отклонения скоростей $\Delta \vect{v}_i$
        подавляются полностью. Это действие необходимо также производить на каждом шаге, после
        интегрирования скоростей, но до~демпфирования, иначе из-за порождённых колебаний система
        может стать нестабильной.
        \end{original}

        It is required to provide the ability to define a set of vertices which saves its shape:
        a~\emph{rigid frame}. The same technique is used here as in the damping algorithm described
        in sec.~\ref{sssec:proposed_changes}. The only difference is that the factor $k$
        in~\eqref{eq:damping} is assumed to be equal to 1. That is, the individual deviations of
        velocities are suppressed entirely. This action should be also done at each step after
        integrating velocities but before damping. Otherwise the simulation may become unstable due
        to the oscillations caused by this interference.

      \subsubsection{Obtaining information about external actions}\label{sssec:external_forces}

        \begin{original}
        Деформация объекта происходит по причине внешних воздействий на него, наиболее интересными
        из которых являются столкновения~--- они и приводят к наибольшим деформациям. Количественно
        столкновение может быть задано как~в виде силы, действующей в~течение определённого времени, так и
        в~виде мгновенно сообщаемого объекту изменения импульса.
        Система поддерживает оба формата, что позволяет интегрировать её в приложение независимо от
        того, какой способ задания столкновений в~нём используется.
        Любое внешнее воздействие оказывается локально, поэтому необходимо также указать область,
        в~которой оно действует.
        \end{original}

        Deformation of the object is caused by external actions, collisions being the most
        interesting of them, since they cause the most strong deformation. Quantitatively the
        collision may be defined either as a force acting during definite short time span, or as a
        change of momentum which is imparted instantly to the object. The system supports both
        formats thus being applicable independent on the variant used in the host application. Any
        external action is local, so in both cases the region of the action is also indicated.

      \subsubsection{Detecting events}\label{sssec:events}

        \begin{original}
        Следствием деформации объекта в~приложениях виртуальной реальности является не только
        изменение формы его отображаемой модели. Типичные события и их последствия могут быть
        наглядно продемонстрированы на примере автомобильного симулятора. Хрупкие объекты, такие как
        стёкла и зеркала, должны разрушаться при прямом ударе или значительном изменении формы их
        рамы. Двигатель должен перестать работать при сильной деформации кузова около него.
        Наконец, автомобиль должен замедлиться, если кузов деформирован настолько, что задевает
        дорогу. Таким образом, требуется, чтобы система моделирования деформаций обнаруживала
        происходящие события и сообщала о них. Данная система может обнаружить следующие события:
        \begin{enumerate}
          \item Удар в~заданною область, превышающий по~силе заданный порог.
          \item Отклонение некоторой точки объекта от~начальной формы больше заданного предела
          (сильная локальная деформация).
          \item Вход некоторой точки в~заданную область (или выход из~неё).
        \end{enumerate}
        Способ обнаружения каждого из событий описан далее. Интерфейс для уведомления об
        обнаруженном событии рассматривается в п.~\ref{sssec:reactions}.
        \end{original}

        \begin{original}
        \paragraph{Удар в заданную область.}
        Простейшее событие~--- это удар в некоторую область, заданную массивом индексов
        входящих в~неё вершин. Для его определения нужно лишь проверить, входит ли хоть одна из этих
        вершин в~зону действия удара и превышает~ли изменение её скорости пороговую величину.
        \end{original}

        \begin{original}
        \paragraph{Отклонение от начальной формы.}
        Для определения таких событий необходимо отдельно хранить начальную позицию каждой вершины.
        То, что вычисления производятся в~системе центра масс, упрощает определение
        отклонения. За~счёт того, что постоянные смещения и повороты, не~являющиеся деформациями,
        автоматически исключаются, отклонение может быть вычислено просто как разность текущей и
        начальной позиции.

        Однако при наличии жёсткой рамы эта разность уже не характеризует деформацию. Рама может
        двигаться относительно центра масс, и её вершины при этом будут иметь ненулевое отклонение
        от начальных позиций. Но на~самом деле форма рамы не~изменилась, так что считать, что событие
        произошло, в~этом случае неверно. Чтобы исключить такие ложные события, необходимо определить смещение и поворот
        рамы в~системе центра масс относительно начального положения. Если перед сравнением позиции
        вершины с~её начальной позицией вычесть это смещение и поворот, то позиции вершин рамы
        всегда будет совпадать с~начальными. Смещение и поворот можно определить, интегрируя на
        каждом шаге линейную и угловую скорость рамы. Но для того, чтобы <<вычесть>> поворот,
        необходимо обратить матрицу поворота (для чего её достаточно транспонировать, так~как она
        ортогональна). Чтобы не делать этого на каждом шаге алгоритма, можно просто интегрировать угловую
        скорость с~противоположным знаком.

        \paragraph{Вход в~заданную область.}
        Координаты, в которых задана область, логично связать с~неподвижной рамой. Для этого, как и
        в~случае с определением отклонения от начальной формы, описанным выше, перед проверкой на принадлежность
        области необходимо подвергнуть позицию вершины смещению и повороту, обратным к смещению и
        повороту рамы.
        \end{original}

      \subsubsection{Support for high-polygonal meshes}\label{sssec:hi-poly}

        \begin{original}
        \paragraph{Преобразование позиций.}
        Отображение деформаций низкополигональной физической модели объекта на высокополигональную
        отображаемую сетку реализуется с~использованием того, что остаточная деформация кластера и
        его текущее состояние хранятся в~нём в~виде матриц.  Для этого необходимо каждую вершину
        высокополигональной сетки также связать с~одним или несколькими кластерами и сохранить её
        исходную позицию. В~каждом кластере её новая позиция рассчитывается аналогично целевым
        позициям в \eqref{eq:goal_pos}. Здесь вместо матрицы оптимального линейного преобразования
        $\matx A$ можно использовать её ортогональную компоненту $\matx R$, характеризующую
        оптимальное вращение, чтобы сильные изменения формы физической модели не отражались на
        отображаемой сетке:
        \begin{equation}\label{eq:graphical_pos}
          \vect{x}'_i = \matx{R} \matx{S}^{ост} (\vect{x}^0_i - \vect{x}^0_{ц.м.}) + \vect{x}_{ц.м.}.
        \end{equation}
        В случае если вершина входит в несколько кластеров, позиции, рассчитанные по этой формуле
        для каждого из них, должны быть усреднены. Полученная в результате позиция и будет позицией
        вершины в деформированной отображаемой сетке.

        \paragraph{Преобразование векторов.}
        Кроме позиции вершина высокополигональной сетки обычно также содержит некоторые связанные векторы:
        например, нормаль к поверхности в данной точке, требующуюся при расчёте освещения, или
        тангенциальный базис для бамп-мэппинга (англ. \eng{bump-mapping}, \cite{blinn-bump}). Их тоже необходимо
        преобразовывать, причём векторы, параллельные поверхности, преобразуются не так, как
        перпендикулярные ей. Параллельный поверхности вектор может быть представлен как разность двух
        принадлежащих касательной плоскости точек, причём если взять их достаточно близкими друг
        к~другу, то можно считать, что они обе лежат на поверхности, и, следовательно, их разность
        преобразуется так же, как и точки поверхности.

        Нормаль же преобразуется иначе. Пусть $\vect n$~---
        нормаль, тогда касательная плоскость в~точке $\vect{x}_0$ описывается уравнением
        \[
        \vect{n}^\transposed (\vect x - \vect{x}_0) = 0.
        \]
        Пусть точки касательной плоскости преобразуются матрицей $\matx M$, тогда, учитывая, что
        $\matx{M}^{-1} \matx{M} = \matx{E}$, уравнение плоскости преобразуется к~виду
        \[
          \vect{n}^\transposed \matx{M}^{-1} \matx{M} (\vect x - \vect{x}_0) = 0,
        \]
        что эквивалентно
        \[
           \left( (\matx{M}^{-1})^\transposed \vect{n} \right)^\transposed (\matx{M} \vect x - \matx{M} \vect{x}_0) = 0.
        \]
        Отсюда следует, что $(\matx{M}^{-1})^\transposed \vect{n}$ является нормалью к преобразованной
        матрицей $\matx M$ касательной плоскости. Итак, перпендикулярные поверхности векторы
        преобразуются транспонированной обратной матрицей к матрице, которой преобразуются позиции
        вершин и векторы, параллельные поверхности.

        Таким образом, итоговые формулы для обновления параллельных и перпендикулярных поверхности
        векторов, соответственно:
        \begin{eqnarray}
          \vect{t}_i\!' & = & \matx{R} \matx{S}^{ост} \vect{t}^{\;0}_i, \label{eq:tangent_vectors} \\
          \vect{n}'_i & = & \left(\left(\matx{R} \matx{S}^{ост}\right)^{-1}\right)^\transposed \vect{n}^0_i. \label{eq:normal_vectors}
        \end{eqnarray}

        \paragraph{Необходимость коррекции векторов.}
        Такие векторы, как нормаль или векторы тангенциального базиса, как правило, должны быть
        нормализованы. Однако описанные выше преобразования векторов не гарантируют сохранения
        нормы. Поэтому, если в~этом есть необходимость, после действия описанного выше преобразования
        они должны быть снова нормализованы в~использующем систему приложении.

        \paragraph{Поддержка произвольной структуры данных.}
        Для обновления отображаемой сетки система обращается к данным, тип которых
        определяется её пользователем. Во избежание сложностей при интеграции ограничений на этот
        тип данных быть не должно, поэтому для задания его структуры
        используется специальный объект <<описатель вершины>>. Пользователь системы создаёт этот
        объект, указывая в~нём размер в~байтах структуры, задающей вершину, и расположение в~ней
        (в~виде смещения от начала структуры в~байтах) полей, хранящих связанные с~вершиной точки и
        векторы, в~том числе, её позицию.  Предполагается, что каждая точка или вектор хранятся
        в~этой структуре как три последовательных числа с~плавающей точкой одинарной точности (тип
        float в~C++)~--- одинарная точность чаще используется при работе с графическим процессором,
        поскольку современные видеоадаптеры пока имеют значительно худшую производительность
        при использовании чисел двойной точности (double) \cite{gpu-float}. Этих точек и
        векторов может быть несколько, поэтому в~описателе вершины хранится массив их смещений,
        кроме того, в отдельном массиве для каждого вектора хранится булевский флаг, задающий,
        является~ли этот вектор параллельным или перпендикулярным поверхности. Указатель на~массив
        вершин отображаемой сетки передаётся как указатель на неопределённый тип (void*)
        в~конструктор класса, представляющего деформируемый объект, где требуется информация о
        начальных позициях вершин для сохранения и привязки вершин к кластерам, и в~функцию
        обновления отображаемой сетки. В~обоих случаях вместе с~указателем на массив вершин
        передаётся описатель вершины, который используется для индексирования этого массива и
        доступа к~хранящимся в~вершине данным.
        \end{original}

    \subsection{Parallel computing}\label{ssec:parallel}

      \begin{original}
      В разделе~\ref{sec:task} было сказано, что одной из задач, поставленных в данной работе, является эффективное использование
      мощности многоядерных процессоров за счёт применения параллельных вычислений.
      Это актуально, поскольку многоядерные процессоры
      приобретают в~последнее время всё большее распространение \cite{steam-hardware}.
      % TODO можно сказать, что сейчас растёт частота, а не количество ядер
      Чтобы расчёты могли выполняться параллельно, необходимо разбить алгоритм на независимые
      блоки, называемые задачами, и реализовать менеджер задач, обеспечивающий их параллельное
      выполнение. Кроме того, часть вычислений по обработке отображаемой сетки может быть перенесена
      на графический процессор.
      % TODO Денис: Вот тут есть концептуальный косяк :) Ты фактически говоришь, что для
      % параллельных вычислений нужно применить метод А. Но ведь есть ещё целая куча других моделей
      % параллельных вычислений (не только задачи). Сети петри, там, можешь ещё про Axum почитать ;)
      % Тут надо либо аккуратно окучить тему, либо чётко описать, почему именно используются задачи.
      \end{original}

      \subsubsection{Splitting algorithm into tasks}\label{sssec:parallel_tasks}

        \begin{original}
        Основной алгоритм содержит этап, состоящих из независимых однотипных блоков
        действий~--- это выполнение сопоставления формы для каждого кластера. Входными данными для
        сопоставления формы являются текущие позиции вершин, и они не изменяются в процессе
        его выполнения. Поэтому не важно, в каком порядке эта операция будет применена ко всем
        % TODO хорошо ли так выделять задачи, не будет ли оверхеда если их сильно много?
        кластерам, и её выполнение для отдельного кластера можно выделить в~качестве независимой задачи. Остальная
        часть алгоритма~--- это действия над всем набором вершин, каждое из которых использует
        результат предыдущего. Их нельзя выполнять параллельно, поэтому все они объединяются в~одну
        задачу, выполняемую после завершения всех задач первого этапа, далее называемую <<задачей
        обработки всего объекта>>. Поскольку матрицы, входящие
        в~формулу \eqref{eq:graphical_pos}, к началу работы над задачей обработки всего объекта уже вычислены,
        расчёт деформации отображаемой сетки может производиться параллельно выполнению этой задачи.
        \end{original}

      \subsubsection{Task manager}\label{sssec:task_manager}

        \begin{original}
        За параллельное выполнение задач и соблюдение порядка, в котором они должны начинать
        исполнение, отвечает менеджер задач. При разработке компонента
        для приложения виртуальной реальности нужно учитывать, что в~этом приложении
        может быть собственный менеджер задач. В этом случае более эффективно
        будет использовать его возможности по распределению задач между потоками, чем делать это
        самостоятельно. Кроме того, исключая зависимость от конкретной библиотеки для управления
        потоками, можно улучшить переносимость системы. Таким образом, система должна лишь
        предоставлять интерфейс для получения и выполнения задач в правильном порядке,
        удовлетворяющий условию потоковой безопасности (англ. \eng{thread-safe}), то есть
        функционирующий корректно при одновременном доступе из нескольких потоков. Далее такой
        интерфейс называется <<потокобезопасной очередью задач>>. Под очередью здесь понимается именно строгий порядок выдачи
        задач на исполнение, завершение предыдущей задачи для начала выполнения следующей не требуется.
        \end{original}

      \subsubsection{Using graphical processor}\label{sssec:using_gpu}

        \begin{original}
        Графический процессор входит во все современные видеоадаптеры и предназначен, в
        первую очередь, для ускорения процесса получения изображения трёхмерной сцены. Современные
        графические процессоры обладают высокой вычислительной мощностью и позволяют выполнять
        расчёты, напрямую не связанные с~созданием изображения. При использовании графического
        ускорителя для таких расчётов вычислительная нагрузка распределяется между ним и центральным
        процессором, что даёт ускорение за счёт их параллельной работы. Применение графического
        процессора для расчётов в~данной системе не должно создать дополнительных системных
        требований у использующего её приложения, поскольку в~последнее время большинство компьютерных игр и
        приложений виртуальной реальности требуют его наличия для расчёта трёхмерной графики. В~случае если
        использование видеоадаптера всё-таки невозможно или является причиной проблем
        с~производительностью, расчёты могут быть выполнены целиком на центральном процессоре, для
        чего система предоставляет отдельный интерфейс.

        \paragraph{Возможности графического процессора.}
        Процесс создания изображения графическим процессором представляет собой конвейер,
        осуществляющий параллельную обработку данных на каждом этапе: отдельных вершин,
        геометрических примитивов и, в~итоге, пикселей отображаемого на экране двумерного
        изображения. За обработку на каждом этапе отвечает специальная программа~--- шейдер,
        применяемая к~каждому обрабатываемому объекту в~отдельности: вершине, примитиву или пикселю.
        Кроме данных текущего объекта шейдер имеет доступ к~данным, одинаковым для всех объектов
        данного этапа~--- константам шейдера.

        \paragraph{Выбор подходящей задачи.}
        В~связи с~перечисленными выше особенностями шейдеров, не всякая задача может быть выполнена
        на графическом процессоре. В~данной работе наиболее подходящей для этого является задача
        вычисления новых позиций вершин отображаемой сетки в~результате деформации. Во-первых, один
        из этапов графического конвейера отвечает именно за обработку вершин. Во-вторых, согласно
        формуле~\eqref{eq:graphical_pos}, для вычисления позиции каждой вершины требуется только её
        начальная позиция и параметры кластеров, одинаковые для всех вершин, то есть только те
        данные, которые доступны в~вершинном шейдере. Наконец, при вычислении используются только
        арифметические операции над векторами и умножение матрицы на вектор, которое может быть
        представлено как последовательные скалярные произведения. Все эти операции присутствуют
        в~наборе инструкций графического процессора.

        \paragraph{Реализация вычислений в вершинном шейдере.}
        Таким образом, вычисление $\vect{x}'_i$ по формуле~\eqref{eq:graphical_pos} и последующее
        усреднение (в случае нес\-коль\-ких кластеров) может быть выполнено в~вершинном шейдере, если
        необходимые параметры всех кластеров (исходный и текущий центр масс и матрица $\matx D =
        \matx{R} \matx{S}^{ост}$) будут переданы в~качестве констант шейдера. Поскольку каждая
        вершина может входить в~несколько кластеров, с~ней необходимо связать индексы кластеров, в
        которые она входит. Аналогичная задача возникает при реализации скелетной анимации с~помощью
        матриц (англ. \eng{Skinning}) \cite{gpu-gems-skinning}, поэтому здесь используется схожий подход.
        Число кластеров, в~которые входит вершина, может быть различным у разных вершин. Поскольку
        структура, задающая вершину, не может иметь переменный размер, то набор индексов задаётся
        в~виде массива фиксированного размера и числа элементов в наборе. Размер массива равен
        максимальному возможному числу кластеров для одной вершины, зависящему от способа разбиения
        на кластеры. Число кластеров и их индексы должны быть заданы для каждой вершины в~процессе
        инициализации объекта. При этом в~основном цикле уже не требуется
        производить запись в~буфер отображаемых вершин, необходимо лишь записывать новые значения
        параметров кластеров в соответствующие константы шейдера. Поэтому в~данном случае описатель
        вершины несёт другую функцию, нежели при вычислении на центральном процессоре: вместо
        расположения в~структуре всех точек и векторов, требующих обновления, он теперь должен
        хранить лишь расположение следующих величин: позиции (требуется для определения
        принадлежности кластерам), числа кластеров и их индексов (будут записаны единожды в
        конструкторе объекта).

        \paragraph{Используемые ресурсы.}
        Константы шейдера хранятся в~специальных регистрах графического процессора. Каждый такой регистр
        представляет вектор из четырёх компонент~--- чисел с плавающей точкой одинарной точности
        (float). В используемом методе требуется для каждого
        кластера передавать в шейдер две матрицы $3 \times 3$ (для преобразования точек и нормалей) и два
        вектора~--- начальный и текущий центр масс. Вектор текущего центра масс можно объединить с
        матрицей преобразования точек в матрицу $3 \times 4$. Каждая матрица занимает 3~регистра,
        поэтому всего на каждый кластер требуется 7~регистров. Несмотря на то, что система
        поддерживает произвольное число кластеров, количество доступных регистров для констант
        шейдера накладывает на него ограничение, которое должно быть учтено пользователем системы.
        Подробнее эта проблема рассмотрена в п.~\ref{sssec:limitations}.
        \end{original}

  \section{System implementation}

    \begin{original}
    Система реализуется в~виде модуля, который может быть встроен в~приложение виртуальной
    реальности: статической либо динамической библиотеки, написанной на языке C++. Выбор языка
    обоснован компромиссом между быстродействием и удобством разработки и интеграции, которые
    обеспечивает использование объектно-ориентированной парадигмы. Не менее важно, что большинство
    компьютерных игр и~других приложений виртуальной реальности написаны именно на этом языке
    программирования, поэтому требование лёгкости интеграции также влияет на выбор в~пользу C++.

    В~системе выделяются следующие модули:
    \begin{enumerate}
      \item Ядро системы, обеспечивающее собственно моделирование.
      \item Подсистема математических расчётов.
      \item Подсистема журналирования и~обработки ошибок.
    \end{enumerate}

    В последующих подразделах подробно рассмотрена структура каждого из модулей: входящие в~него
    классы, их методы и связи друг с~другом.

    \subsection{Ядро системы}

      Основным классом подсистемы является Model, физическая модель деформируемого объекта.
      Далее описаны различные подробности его реализации и интерфейса. В завершение приводится
      типичный сценарий его использования в приложении виртуальной реальности.

      \subsubsection{Представление объекта}\label{sssec:representation}

        Физическая конфигурация деформируемого объекта (форма и распределение массы) и отображаемая форма описываются
        массивами вершин соответствующих классов: PhysicalVertex и GraphicalVertex. Оба вида вершин
        группируются в~кластеры, за что отвечает класс Cluster. Как уже говорилось в
        п.~\ref{sssec:hi-poly}, описатель вершины, объект класса VertexInfo, используется для
        конвертации вершин из формата, используемого в~приложении, во внутренний формат и обратно.

        \includefigure{представление моделируемого объекта в системе}{core-vertices}

        Отдельного внимания требует реализация группировки физических и графических вершин в
        кластеры. Помимо того, что объект класса Cluster хранит динамические массивы указателей
        обоих типов, некоторая информация, связанная с принадлежностью к кластеру, должна сохраняться и в самих вершинах. В случае физических
        вершин поправка к скорости от каждого кластера записывается в отдельную ячейку массива,
        хранящегося в вершине, во избежание конфликтов при доступе из разных потоков (подробнее это
        будет объяснено при описании реализации параллельных вычислений далее в этом же подразделе).
        В случае отображаемых вершин нужно сохранять индексы всех кластеров, в которые входит
        вершина для переноса деформации на отображаемую сетку на графическом процессоре (см.
        п.~\ref{sssec:using_gpu}). Итак, с каждой из вершин обоих типов должен быть связан массив,
        причём одному элементу массива соответствует один кластер, в который входит эта вершина.
        Использование динамических массивов для этой цели не является оправданным, в связи с большим
        числом тех и других вершин, а так же с тем, что вершина обычно входит в небольшое число
        кластеров (будет объяснено ниже). Поэтому
        максимальное число кластеров, в которое может входить та или иная вершина, ограничивается
        сверху и используется статический массив.

        \begin{myfigure}{два способа задания кластеров}{fig:clusters}
          \subfigure[width=0.4\textwidth]{Автоматическое регулярное разбиение}{clusters-automatic}
          \hspace{0.1\textwidth}
          \subfigure[width=0.4\textwidth]{Задание произвольных областей}{clusters-arbitrary}
        \end{myfigure}

        Кластеры могут быть заданы двумя способами. В простейшем случае можно выполнить автоматическое
        разбиение объекта плоскостями, перпендикулярными каждой из осей и делящими ось на равные
        отрезки. Для этого в конструктор объекта нужно передать требуемое количество кластеров по
        каждой из осей и степень их перекрытия (в процентах от ширины). При этом одна вершина может
        входить не более чем в 8 кластеров одновременно (максимум достигается, если она находится
        в области перекрытия по всем трём координатным направлениям). Поэтому 8 можно взять в качестве
        максимально допустимого числа кластеров для одной вершины.

        Автоматическое разбиение на кластеры
        вполне подходит для однородных объектов простой формы. Если же это не так, можно задать
        кластеры произвольной формы вручную. При этом в конструктор передаётся набор областей в
        пространстве, на основе каждой из которых строится кластер, содержащий все вершины, входящие
        в эту область. Набор областей представляется в виде динамического массива указателей на
        экземпляры класса IRegion, описанного ниже.
        % TODO пояснить иллюстрацию словами

      \subsubsection{Внешние воздействия}
        Как было сказано в п.~\ref{sssec:external_forces}, информация о~воздействиях может быть
        сообщена объекту двумя способами: в~виде моментального изменения импульса и в~виде сил,
        действующих в~течение некоторого времени. Первый способ реализует функция Model::hit,
        которая мгновенно изменяет скорость вершин, входящих в~заданную область. Область
        в~трёхмерном пространстве представляется абстрактным классом IRegion с~чисто виртуальным
        методом contains для проверки принадлежности точки этой области. В~библиотеке представлены
        несколько простейших реализаций (сферическая, цилиндрическая область и~др.), а~необходимые
        в~конкретном случае более сложные области пользователь системы может реализовать в
        производном классе.

        Для второго способа используется абстрактный класс Force, описывающий поле сил, действующее
        в~определённой области пространства. Для применения этого способа нужно при расчёте шага
        алгоритма передать массив указателей на экземпляры классов-наследников Force, описывающих
        приложенные к объекту силы. Действие этих сил будет учтено при интегрировании скоростей. Для
        создания собственной реализации силы необходимо в~классе, производном от Force, определить
        метод is\_applied\_to, определяющий, приложена ли сила к~вершине, находящейся в данной
        точке, и метод get\_value\_at, возвращающий вектор силы в этой точке.

        \includefigure{получение информации о внешних воздействиях.}{core-interaction}

      \subsubsection{Характеристики объекта как целого}

        Как уже упоминалось в п.~\ref{sssec:proposed_changes} и п.~\ref{sssec:events}, в~процессе
        моделирования возникает необходимость в~определении усреднённых линейной и угловой скоростей
        объекта и рамы и в последующем интегрировании этих скоростей. Первую задачу решает класс
        DiscreteBody, вторую~--- RigidBody. Класс DiscreteBody также отвечает за демпфирование колебаний
        объекта и обеспечение движения рамы как твёрдого тела. Он позволяет привести скорости всех
        входящих в него вершин к вычисленным усреднённым величинам (с~некоторым коэффициентом или в
        точности). В~свою очередь, RigidBody позволяет интегрировать движение, обратное
        к движению жёсткой рамы: получаемая при этом матрица поворота используется в процессе
        обнаружения отклонения вершины от начальной позиции (см. п.~\ref{sssec:events}).

        \includefigure{расчёт и интегрирование характеристик объекта как целого.}{core-bodies}

      \subsubsection{Реакции на события}\label{sssec:reactions}

        События, которые могут быть обнаружены в процессе моделирования деформаций, были описаны в
        п.~\ref{sssec:events}. Реакция на~каждый тип события реализуется как класс с~чисто
        виртуальным методом invoke, который пользователь системы определяет в~своём производном
        классе. Этот метод будет вызван, когда событие произойдёт. Использование такого класса
        вместо простого указателя на функцию позволяет связать с каждой отдельной реакцией как
        системную информацию о параметрах события, так и произвольные пользовательские данные,
        используемые в~теле основного метода. В~первом случае информация хранится в приватных полях
        базового класса, во~втором~--- в~полях, объявленных пользователем в производном классе.

        \includefigure{определение реакции на события.}{core-reactions}

        Каждому из трёх типов обнаруживаемых событий: удар в~заданное множество вершин, отклонение от
        начальной формы и вход в~заданную область~--- соответствует свой абстрактный базовый класс: HitReaction,
        ShapeDeformationReaction или RegionReaction, соответственно.
        Каждый из этих классов содержит параметры события, которые
        нужно передать в~его конструктор. Для HitReaction это пороговая абсолютная величина
        изменения скорости вершины при ударе, а также множество вершин, заданное набором индексов вершин
        в~массиве, в котором они были переданы в~конструктор объекта. Параметрами для
        реакции на изменение формы являются множество вершин, заданное аналогичным образом, и минимальное
        отклонение позиции вершины от начальной позиции, при котором событие считается произошедшим.
        RegionReaction хранит в себе указатель на IRegion, также при создании можно указать, что
        является событием: вход в заданную этим указателем область или выход из неё.

        Класс Model хранит массивы указателей на базовый класс реакции каждого типа и содержит
        методы для добавления в них указателей на экземпляры производных пользовательских классов:
        add\_hit\_reaction, add\_shape\_deformation\_reaction и add\_region\_reaction (не были
        показаны на диаграммах для краткости).

      \subsubsection{Параллельные вычисления}

        Как уже говорилось в подразделе~\ref{ssec:parallel}, алгоритм разбивается на задачи, параллельное
        выполнение которых обеспечивается менеджером задач. В~данном случае менеджер задач представляет собой
        потокобезопасную очередь, описанную в п.~\ref{sssec:task_manager}. Различные задачи
        наследуются от базового класса AbstractTask, содержащего чисто виртуальный метод выполнения
        задачи.  Поскольку задача обработки всего объекта должна выполняться после завершения всех
        задач первого этапа, она добавляется в~очередь последней. Кроме того, в её начале
        выполняется ожидание всех событий, устанавливаемых при завершении каждой из задач первого
        этапа, чтобы гарантировать то, что эти задачи уже выполнены, поскольку очередь задач этого не гарантирует.

        Использование каких-либо определённых примитивов синхронизации может ухудшить переносимость
        системы. Необходимо предоставить возможность для замены используемого набора примитивов.
        Это достигается за счёт использования шаблона проектирования <<Абстрактная фабрика>> (англ. \eng{Abstract
        Factory}). Различные примитивы представлены в виде абстрактных классов, а отдельный
        абстрактный класс (<<фабрика>>) содержит методы для создания экземпляров каждого из этих
        классов. Для замены набора примитивов достаточно передать в~систему новую реализацию
        <<фабрики>>.

        \includefigure{абстрактная фабрика примитивов синхронизации.}{parallel}

        Впрочем, необходимо с~осторожностью использовать блокирующие примитивы синхронизации для
        ограничения доступа к разделяемым данным, поскольку их неправильное применение может
        привести к~тому, что задачи, ожидающие доступ к~этим данным, будут выполняться
        последовательно, а не параллельно.  Например, в~данной задаче поправки к скорости вершины от
        разных кластеров усредняются. Если суммировать поправки по мере их вычисления, во время
        выполнения операции суммирования только один поток должен иметь доступ к области памяти,
        в~которой хранится сумма. Остальные потоки, которые также готовы выполнить суммирование,
        будут в~это время простаивать. Чтобы избежать этого, каждый кластер записывает свою поправку
        в~отдельную область памяти, и суммируются они уже после завершения расчётов для кластеров:
        это действие входит в задачу обработки всего объекта, выполняемую последней.

      \subsubsection{Использование}\label{sssec:usage}

        Таким образом, типичный сценарий работы с~классом Model следующий. Инициализация:
        \begin{enumerate}
          \item Создание экземпляра: в конструктор передаются исходные массивы физических и
          отображаемых вершин, их описатели (VertexInfo), а также параметры разбиения на кластеры.
          \item Задание недеформируемой рамы: метод set\_frame (необязательно).
          \item Определение реакций на события: методы add\_hit\_reaction,\\
          add\_shape\_deformation\_reaction и add\_region\_reaction\\
          (необязательно).
        \end{enumerate}
        Повторяется при расчёте нового кадра:
        \begin{enumerate}
          \item Сообщение об ударе: метод hit (возможно, не на каждой итерации).
          \item Расчёт шага алгоритма.
          \item Обновление отображаемой сетки.
        \end{enumerate}
        Второй и третий пункт будут подробнее описаны в последующих абзацах

        \paragraph{Расчёт шага алгоритма.}
        В случае однопоточного приложения расчёт шага алгоритма происходит при вызове метода
        compute\_next\_step. В случае многопоточного ~--- при выполнении следующей
        последовательности действий:
        \begin{enumerate}
          \item Подготовка очереди задач: метод prepare\_tasks.
          \item Выполнение очередной задачи (может вызываться параллельно из нескольких потоков): метод complete\_next\_task.
          \item Ожидание окончания расчёта кластеров, после чего можно
            обновлять отображаемую сетку: метод wait\_for\_clusters.
          \item Обнаружение произошедших событий: метод
            react\_to\_events (может выполняться параллельно выполнению последней задачи,
            как и обновление отображаемой сетки).
        \end{enumerate}

        \paragraph{Обновление отображаемой сетки.}
        Чтобы выполнить обновление вершин отображаемой сетки на центральном процессоре, необходимо вызвать метод
        update\_vertices, передав ему указатель на массив вершин и описатель вершины.
        Если же используется графический процессор, то вместо этого необходимо
        получить параметры кластеров (матрицы преобразования вершин и нормалей, а также начальный и
        текущий центр масс) с помощью соответствующих методов и передать их в константные регистры
        вершинного шейдера. Важно, что при этом пользователь системы должен выделить в своей структуре,
        представляющей отображаемую вершину, место для хранения массива индексов кластеров и их
        числа. Как было показано в п.~\ref{sssec:using_gpu}, эти данные требуются для расчёта
        позиций отображаемых вершин на графическом процессоре. Пользователь должен также реализовать
        в своём вершинном шейдере вычисление новых позиций вершин и значений точек и векторов,
        связанных с вершинами, по формулам \eqref{eq:graphical_pos}--\eqref{eq:normal_vectors}.
        Для этого вместе с библиотекой предоставляется фрагмент исходного кода шейдера на языке HLSL,
        выполняющий эти вычисления, так что он может быть вставлен в шейдер, если он также написан
        на HLSL. В противном случае необходимо портировать этот фрагмент на используемый язык.

    \subsection{Подсистема математических расчётов}\label{sssec:math}

        Для функционирования основного алгоритма, описанного в подразделе \ref{ssec:basic_algorithm}, требуются
        функции векторной и матричной алгебры для работы с векторами в трёхмерном пространстве и с
        матрицами $3 \times 3$. Для этого подсистема математических расчётов содержит
        классы Vector и Matrix, реализующие стандартный набор алгебраических операций. Нетривиальные
        функции описаны ниже.

        \paragraph{Обращение матрицы.}
        Обратная матрица находится как транспонированная матрица алгебраических дополнений, делённая
        на определитель исходной матрицы. Этот метод значительно проще более популярного в~случае
        больших размерностей метода Гаусса~--- Жордана. Поскольку в~данной работе требуется
        оперировать только матрицами $3 \times 3$, и обращение матрицы не является узким местом
        алгоритма, был сделан выбор в~пользу более простого для реализации метода.

        \paragraph{Полярное разложение.}
        Полярное разложение матрицы $\matx M$ на ортогональную $\matx R$ и симметричную $\matx S$ компоненты
        $\matx M = \matx R \matx S$ осуществляется следующим образом:
        \begin{eqnarray*}
          \matx S & = & \sqrt{\matx{M}^\transposed \matx{M}},\\
          \matx R & = & \matx M \matx{S}^{-1}.
        \end{eqnarray*}
        Вычисление квадратного корня от симметричной матрицы $\matx S$ описано ниже.

        \paragraph{Вычисление функции от симметричной матрицы.}
        Для вычисления функции от симметричной матрицы она диагонализуется (это всегда возможно,
        поскольку она симметрична), после чего функция применяется к
        диагональным элементам, и матрица преобразуется обратно в исходный базис.

        \paragraph{Диагонализация симметричной матрицы.}
        Приведение к диагональному виду симметричной матрицы осуществляется методом вращений Якоби (англ.
        \eng{Jacobi rotation})~--- быстрым приближенным итеративным методом \cite{fortran-jacobi}.

    \subsection{Подсистема журналирования и обработки ошибок}

        \includefigure{структура подсистемы журналирования и обработки ошибок.}{logging}

        Данная подсистема обеспечивает обработку ошибок и~предупреждений, возникающих в~процессе
        работы системы, а~также запись в журнал. В приложении, использующем систему, может
        быть реализована своя политика журналирования и обработки ошибок. Для удобства интеграции
        эта подсистема предоставляет пользователю системы возможность определить свои действия по
        журналированию и обработке ошибок, а также обеспечивает возможность инициировать эти действия
        отовсюду внутри системы.
        Основной класс этой подсистемы, Logger, реализует шаблон проектирования <<Одиночка>> (англ.
        \eng{singleton}), что обеспечивает работу с единственным объектом во всей системе,
        кроме того, нет необходимости передачи его по всей цепочке вызовов. Чисто виртуальный класс Action
        используется для задания действия, выполняемого в ответ на то или иное событие (запись в
        журнал, предупреждение, ошибка). В подсистеме представлены простейшие реализации действий по
        умолчанию, пользователь же может определить своё действие в~классе, производном от Action. Класс
        Logger содержит следующие методы:
        \begin{enumerate}
          \item Определение действия для конкретного события: метод set\_action.
          \item Отключение реакции на конкретное событие: метод ignore.
          \item Вызов действия (используется внутри системы): метод invoke.
        \end{enumerate}

  \section{Testing}

      Корректность работы системы была протестирована на двух уровнях: на уровне отдельных функций и на
      уровне системы в~целом. Для тестирования отдельной функции применяется модульное тестирование (англ. \eng{unit testing}):
      пишется несколько тестов, проверяющих корректность её работы в~характерных случаях. Таким
      образом удобно тестировать все функции подсистемы математических расчётов и подсистемы
      журналирования и обработки ошибок, функции доступа к~полям классов, обработку некорректных
      аргументов, расчёт таких предсказуемых величин, как центр масс кластера или
      момент инерции объекта. Преимуществами модульного тестирования являются лёгкость локализации ошибки
      (за счёт того, что сразу известно, какая функция работает некорректно) и возможность
      убедиться, что система по-прежнему работоспособна после внесения изменений, в~том числе
      после рефакторинга или оптимизации. В~то же время, не менее важно тестировать правдоподобность
      моделируемых деформаций. Но сформулировать математический критерий правдоподобности сложно,
      поэтому модульные тесты плохо подходят для такого тестирования. Чтобы оно могло осуществляться
      человеком, разработано простое интерактивное приложение, позволяющее пользователю подвергать
      тестовый объект различным воздействиям и наблюдать изменения, происходящие при этом с
      трёхмерной моделью объекта.
      \end{original}

  \section{Results}\label{sec:results}

    \begin{original}
    Система моделирования деформаций была реализована в~виде статической
    библиотеки объектных модулей, написанной на языке C++. Было разработано тестовое приложение,
    использующее эту библиотеку, которое средствами API DirectX~9 отображает трёхмерную модель
    объекта и позволяет моделировать его деформации под действием ударов с разных сторон. Трёхмерная
    модель может быть загружена в приложение из файла либо сгенерирована по заданным параметрам при
    запуске.

    С использованием тестового приложения был проведён ряд экспериментов над тестовыми объектами.
    В ходе экспериментов измерена производительность системы, определены оптимальные параметры алгоритма,
    % TODO Денис: сначала даются ограничения, а потом делается система. А у тебя вышло, что ты её сделал, а потом сказал ограничения
    выявлены основные требования к~входным данным и прочие ограничения, а~также обнаружены некоторые
    особенности используемого метода моделирования. Эти результаты представлены в~последующих подразделах.

    \subsection{Тестовые объекты}\label{ssec:test_objects}

      Для проверки правдоподобности деформаций и измерения производительности использовались два
      тестовых объекта: <<Цилиндр>> (с~простой геометрией) и <<Автомобиль>> (с~более сложной
      геометрией), они рассмотрены далее.

      \subsubsection{Цилиндр}\label{sssec:cylinder}

        В качестве объекта с простой геометрией используется цилиндр, содержащий
        \num{2362} точки в физической модели, сгруппированные в 16 кластеров, и \num{20102} вершины (\num{40398}
        треугольников) в отображаемой сетке. Исходная форма объекта на рис.~\ref{fig:cylinder-initial}.

        \begin{myfigure}{тестовый объект <<Цилиндр>>}{fig:cylinder}
          \subfigure[width=0.25\textwidth]{Исходное состояние}{cylinder-initial}    \hspace{1cm}
          \subfigure[width=0.25\textwidth]{Удар в середину}   {cylinder-deformed-1} \\
          \subfigure[width=0.25\textwidth]{Удар в край}       {cylinder-deformed-2} \hspace{1cm}
          \subfigure[width=0.25\textwidth]{Комбинация ударов} {cylinder-deformed-3}
        \end{myfigure}

        Были протестированы следующие случаи воздействия на объект:
        \begin{enumerate}
          \item Поперечный удар в середину объекта, см. рис.~\ref{fig:cylinder-deformed-1}.
          \item Продольный удар в край объекта, см. рис.~\ref{fig:cylinder-deformed-2}.
          \item Комбинация ударов, см. рис.~\ref{fig:cylinder-deformed-3}.
        \end{enumerate}

        Также было проведено исследование зависимости времени расчётов от числа вершин в физической
        модели и отображаемой сетке. Для каждого числа вершин производилось 5 запусков тестового
        % TODO померить действительно в таких условиях
        приложения, каждый из которых длился 10 секунд. На объект оказывались одинаковые воздействия. Во время
        исполнения на каждом кадре измерялось время, требуемое для физического моделирования и для
        вычисления позиций вершин отображаемой сетки. По получаемой выборке рассчитывалось
        % TODO больше думать про обработку данных
        среднее значение. Многократные запуски необходимы, чтобы исключить
        факторы, внешние по отношению к~приложению, например, загрузку процессора другими приложениями
        и операционной системой. Измерения производились на компьютере со следующими
        характеристиками: четырёхъядерный процессор Intel Core 2 Quad Q6600, тактовая частота
        \num{2.4} ГГц, видеоадаптер NVIDIA GeForce 8800 GTX.
        Результаты измерений представлены в виде графика на рис.~\ref{fig:time-plot}.

        \includefigure[width=1\linewidth]{зависимость времени моделирования от числа физических вершин
        и времени обновления отображаемых вершин (на центральном либо графическом процессоре) от их
        числа.}{time-plot}

        \paragraph{Выводы.} Зависимость от числа вершин обоих типов близка к линейной.
        Горизонтальный участок зависимости для отображаемых вершин связан с тем, что, даже когда
        вычисления на графическом процессоре занимают очень мало времени, имеются
        постоянные накладные расходы времени. Например, на передачу данных между графическим и центральным
        процессором и на растеризацию изображения. Из графика следует, что затраты времени на
        одну вершину физической модели значительно выше затрат на одну отображаемую вершину. Таким
        образом, использование физической модели с~меньшим числом вершин и последующий перенос
        её деформаций на отображаемую сетку с~б\'{о}льшим числом вершин оправданы.
        Более того, выполнение этого переноса на графическом процессоре позволяет получить
        существенный выигрыш по времени по сравнению с использованием центрального процессора для
        этой цели.

      \subsubsection{Автомобиль}\label{sssec:car}

        В качестве объекта со сложной геометрией используется автомобиль, содержащий
        \num{9413} точек в физической модели, сгруппированные в~24 кластера, и \num{28241} вершин (\num{34534}
        треугольника) в отображаемой сетке. Исходная форма объекта показана на рис.~\ref{fig:car-initial}.

        \begin{myfigure}{тестовый объект <<Автомобиль>>}{fig:car}
          \subfigure[width=0.3\textwidth]{Исходное состояние}{car-initial}    \hspace{1cm}
          \subfigure[width=0.3\textwidth]{Удар в середину}   {car-deformed-1} \\
          \subfigure[width=0.3\textwidth]{Удар в край}       {car-deformed-2} \hspace{1cm}
          \subfigure[width=0.3\textwidth]{Комбинация ударов} {car-deformed-3}
        \end{myfigure}

        Были протестированы следующие случаи воздействия на объект:
        \begin{enumerate}
          \item Поперечный удар в середину объекта, см. рис.~\ref{fig:car-deformed-1}.
          \item Продольный удар в край объекта, см. рис.~\ref{fig:car-deformed-2}.
          \item Комбинация ударов, см. рис.~\ref{fig:car-deformed-3}.
        \end{enumerate}

        Чтобы проверить масштабируемость многопоточного алгоритма, было проведено сравнение быстродействия
        версий тестового приложения с разным числом рабочих потоков, от 1 до 4, на четырёхъядерном
        процессоре. Как было показано в п.~\ref{sssec:parallel_tasks}, вычисления разбиваются на два
        этапа, и только задачи первого этапа независимы и выполняются параллельно, а остальные
        вычисления производятся после завершения первого этапа. Поэтому измерялось отдельно время,
        требуемое для каждого этапа. Ожидалось, что для первого этапа оно будет убывать обратно
        пропорционально числу потоков, а для второго этапа~--- оставаться неизменным.
        Измерения производились на компьютере со следующими характеристиками: четырёхъядерный
        процессор Intel Core i5-750, тактовая частота \num{2.66} ГГц, видеоадаптер NVIDIA GeForce GTS 250.
        Полученные результаты представлены на рис.~\ref{fig:thread-plots}: диаграмма на
        рис.~\ref{fig:time-plot-threads} показывает зависимость времени расчётов от числа потоков, а
        график на рис.~\ref{fig:speedup-plot}~--- выраженное в процентах отношение затрат времени
        однопоточной версией к затратам при нескольких параллельных потоках, показывающее, во сколько раз
        многопоточная версия системы быстрее однопоточной.
        % TODO время расчётов на GPU тоже бы

        \begin{myfigure}{зависимость скорости вычислений от числа потоков, выполняющихся на разных ядрах процессора}{fig:thread-plots}
          \subfigure[width=0.45\textwidth]{Время вычислений}{time-plot-threads}
          \subfigure[width=0.45\textwidth]{Отношение скоростей вычислений многопоточной и однопоточной версии}{speedup-plot}
        \end{myfigure}

        \paragraph{Выводы.}
        Наблюдается рост скорости той части вычислений, которая выполняется параллельно, при увеличении числа потоков.
        Характер этого роста близок к линейному, но при одновременной работе всех четырёх
        ядер процессора достигается ускорение только в~\num{2.2} раза. Такое ускорение оправдывает
        применение многопоточности в данной системе при использовании её на многоядерных процессорах, но не
        является максимальным достижимым. Этот факт указывает на то, что имеется возможность для
        дальнейшего улучшения реализации параллельных вычислений.

        В~целом, было показано, что поставленная цель достигнута: система моделирует визуально
        правдоподобные деформации объектов, имеющих типичную для приложений виртуальной реальности
        степень детализации, и на расчёты требуется менее 3 мс на кадр. Тем не менее, для этого
        должны быть соблюдены определённые условия, подробно описанные далее.

    \subsection{Требования к входным данным}\label{ssec:requirements}

      \paragraph{Требования к представлению объекта.}
      Жёсткость конкретной области поверхности объекта существенно зависит от плотности точек в этой
      области. Во-первых, если между соседними точками имеется значительный промежуток, то изгиб
      объекта в~этом промежутке не может быть смоделирован из-за отсутствия в~нём точек. Во-вторых,
      проблема возникает, если значительная по объёму часть кластера содержит намного меньше точек,
      чем остальная часть кластера. Тогда при сопоставлении формы вклад этого небольшого числа точек будет
      также незначителен, и, несмотря на сильное отклонение в этой области, деформация всего
      кластера может оказаться слабой. Таким образом, чтобы моделирование было реалистичным,
      фрагменты модели, состоящие из однородного материала, должны представляться набором точек
      равномерной плотности.

      \paragraph{Требования к разбиению на кластеры.}
      Используемый метод сопоставления формы накладывает ограничение на исходную форму, образуемую
      вершинами одного кластера. При сопоставлении формы вычисляется оптимальное линейное преобразование
      множества точек, входящих в кластер, переводящее его из исходного состояния в наиболее близкое
      к текущему. Это преобразование будет неоднозначным, если множество точек лежит в одной
      плоскости или на одной прямой, будь то в исходном или текущем состоянии. Если такую форму
      имеет текущее состояние кластера, сопоставление формы на этом шаге может быть пропущено, а значений
      целевых позиций могут быть взяты с прошлого шага. Если же проблема заключается в
      исходной форме, сопоставление формы не сможет быть выполнено ни на одном шаге, поэтому система сообщит
      об ошибке при попытке создания объекта, содержащего хотя бы один такой некорректный кластер.
      В этом случае нужно либо изменить разбиение на кластеры, либо добавить в некорректный кластер
      дополнительные точки, например, разделив плоскость на два близких слоя с~массой, равной
      половине исходной массы.

    \subsection{Особенности используемого метода}\label{ssec:special_features}

      Поскольку основной алгоритм является геометрическим, при определённых условиях моделирование
      может быть нереалистичным. Далее описаны некоторые характерные свойства этого алгоритма и их
      влияние на реалистичность деформаций.

      \paragraph{Свойства области пересечения кластеров.} Было обнаружено, что удар в область,
      принадлежащую только одному кластеру, и удар в область пересечения кластеров оказывают
      различное влияние на объект. А именно, во втором случае область распространения деформаций
      оказывается больше из-за того, что большее число кластеров изменяет свою форму. Это свойство
      может быть использовано, чтобы моделировать ребро жёсткости областью пересечения соседних
      % TODO подумать, насколько это реально
      кластеров: её собственная форма будет изменяться слабо (поскольку входящие в неё кластеры
      будут примерно одинаково изменять свою форму), но при этом удар непосредственно в неё будет
      оказывать большое влияние на соприкасающиеся кластеры. Если же это не требуется, такое
      свойство может быть нежелательным побочным эффектом. В дальнейшем планируется предусмотреть
      возможность ограничения области распространения удара, чтобы исключить эту проблему.

      \paragraph{Невозможность сложных деформаций отдельного кластера.} В связи с тем, что для сохранения
      деформируемого состояния каждого кластера используется матрица $3 \times 3$, задающая
      линейное преобразование, множество возможных деформаций отдельного кластера ограничено комбинациями
      поворотов, сжатий и продольных сдвигов. Это может быть полезным, если не требуется
      моделировать изгиб частей объекта, задаваемых кластерами. Но в большинстве случаев это не
      так, поэтому требуется учащение разбиения на кластеры в местах, где моделирование
      изгибов необходимо.

    \subsection{Оптимальные значения параметров}\label{ssec:optimal_parameters}

      Характерным свойством геометрических алгоритмов является большое число параметров, изменяя
      которые, можно существенно влиять на процесс моделирования.  В данном случае такими
      параметрами для представления объекта являются распределение плотности точек в
      пространстве, форма и число кластеров, размер и положение недеформируемых частей, а также
      численный параметр~--- коэффициент затухания колебаний. Каждый кластер также имеет свой набор
      параметров, влияющих на моделирование неупругости: порог деформации, после которого начинает
      проявляться неупругость, скорость изменения формы при этом, а также максимальная величина
      остаточной деформации. В процессе исследования были определены допустимые интервалы этих
      параметров, их физический смысл и влияние на характер моделируемых деформаций.

      \paragraph{Плотность точек и разбиение на кластеры} уже были рассмотрены с точки зрения
      их влияния на деформации в подразделах~\ref{ssec:requirements} и \ref{ssec:special_features}.
      Осталось упомянуть о~том, какое число кластеров является типичным для
      деформируемого объекта, используемого в~приложении виртуальной реальности. Тестовый
      объект <<Автомобиль>> из п.~\ref{sssec:car} был разбит на кластеры следующим образом: на 6
      равных частей по длине, на 2 по ширине и высоте (пропорционально отношению соответствующих
      линейных размеров, итого 24), величина области перекрытия~--- 40\% от ширины кластера.
      Как показало тестирование (см. рис.~\ref{fig:car}), такого числа кластеров достаточно для правдоподобного моделирования, но
      в~отдельных случаях движение кластера как целого может быть заметно. Поэтому в~общем случае
      имеет смысл увеличивать количество кластеров до тех пор, пока достаточная детальность
      деформаций не будет достигнута, либо пока не начнут действовать ограничения, описанные ниже в
      п.~\ref{sssec:limitations}.

      \paragraph{Коэффициент затухания колебаний} ($k$) был введён в п.~\ref{sssec:proposed_changes}.
      Он определяет, насколько сильно будут подавляться отклонения скоростей отдельных вершин: $k = 0$
      соответствует отсутствию затухания, $k = 1$~--- полному подавлению отклонений. При $k = 1$
      объект ведёт себя как абсолютно твёрдое тело. При уменьшении он становится мягче (сильнее
      деформируется при одинаковом воздействии), а колебания, возникающие после удара по объекту,
      затухают дольше. При стремлении его к нулю может возникнуть нестабильность из-за того, что
      колебания вообще не будут затухать, либо даже начнут увеличиваться в~амплитуде. В~проведённых
      экспериментах это происходило при значениях $k < \num{0.2}$. Наиболее подходящее для
      конкретного объекта значение нужно подбирать опытным путём. Для~тестовых объектов
      в подразделе~\ref{ssec:test_objects} деформации выглядели наиболее реалистично при следующих
      значениях этого параметра: $k = \num{0.7}$ для объекта <<Цилиндр>> и $k = \num{0.3}$ для
      объекта <<Автомобиль>>.

      \paragraph{Параметры неупругости кластера} напрямую не связаны с~физическими характеристиками
      материала, поскольку для определения меры деформации кластера используется только матрица его
      текущей деформации (см. п.~\ref{sssec:original_algorithm}). Поэтому их величины для каждого
      материала нужно подбирать экспериментально. Их изменения оказывают следующее влияние на
      моделирование:
      \begin{enumerate}
        \item Порог неупругости $d_{неупр}$ определяет меру деформации, при превышении которой
        деформация становится необратимой. Минимальное значение~--- 0, а чем оно больше, тем больше
        может быть сила удара, не оставляющего никаких последствий.
        \item Скорость изменения формы $u$ должна быть строго больше нуля, чтобы остаточная
        деформация сохранялось. Чем она больше, тем быстрее форма кластера приходит в~равновесие, то
        есть меньше длятся колебания. Но если величина $u \Delta t$ превышает единицу, то
        изменение остаточной деформации на одном шаге становится больше величины текущей деформации,
        то есть остаточная деформация начинает опережать текущую, что приводит к ошибочным расчётам.
        Таким образом, $0 < u \le 1/\Delta t$.
        \item Максимальная мера остаточной деформация $d_{max}$ ограничивается, чтобы предотвратить
        слишком сильное изменение формы отдельного кластера, которое будет выглядеть не реалистично.
        Должна быть больше $d_{неупр}$, чтобы остаточная деформация сохранялась.
      \end{enumerate}
      Для тестовых объектов в подразделе~\ref{ssec:test_objects} эти параметры были одинаковы для
      всех кластеров и имели следующие значения: $d_{неупр} = \num{0.1}$, $u = 60$ при
      $\Delta t = \num{0.01}$, $d_{max} = \num{1.5}$.

    \subsection{Ограничения}\label{sssec:limitations}

      Реализация системы не имеет принципиальных ограничений на количество вершин, кластеров и других сущностей,
      используемых при моделировании, поскольку они хранятся в массивах динамически изменяемого размера.
      Тем не менее, в~зависимости от характеристик компьютера, на котором используется система, при слишком
      больших значениях ресурсы этого компьютера могут быть исчерпаны, либо быстродействие системы
      может оказаться ниже требуемого. Эти случаи рассмотрены в последующих пунктах данного
      подраздела.

      Кроме того, ограниченно максимальное число кластеров, в которое может входить одна физическая
      или отображаемая вершина, что было объяснено в п.~\ref{sssec:representation}.

      \subsubsection{Скорость расчёта}\label{sssec:speed_limit}

        Как уже говорилось в разделе~\ref{sec:task}, расчёт одного кадра в приложении виртуальной реальности должен
        занимать не более 33~мс, из которых на расчёт деформаций отводится обычно около 3--5 мс. Рис.~\ref{fig:time-plot}
        из п.~\ref{sssec:cylinder} показывает пример роста времени расчётов в зависимости от основных параметров,
        влияющих на быстродействие: числа физических и отображаемых вершин в представлении объекта.
        Таким образом, для достижения требуемого времени расчётов можно манипулировать обоими
        параметрами. Причём, поскольку в случае физических вершин рост намного быстрее, значительное
        уменьшение их числа является хорошим способом повышения быстродействия без уменьшения
        детализации отображаемой модели объекта. Однако качество моделирования деформаций при этом
        может снизиться.

      \subsubsection{Объём используемой оперативной памяти}

        Наибольший объём памяти в системе требуется для хранения физических и отображаемых вершин в
        силу их большого числа. Размер структур, представляющих каждый вид вершин, зависит от
        максимального числа кластеров, в которое может входить вершина, поскольку, как было показано
        в п.~\ref{sssec:representation}, каждая из вершин хранит статический массив соответствующего
        размера. Далее предполагается, что это число равно 8, оптимальному в большинстве случаев
        согласно рассуждениям в п.~\ref{sssec:representation}.

        % TODO перепроверить цифры, подумать об оптимизации
        Структура, представляющая физическую вершину, занимает в памяти 312 байт. Например, если
        физическое представление объекта должно занимать не более 10 мегабайт, то максимальное
        возможное число вершин в этом представлении~--- \num{32051}. Как уже было сказано выше,
        в п.~\ref{sssec:speed_limit}, это не
        является серьёзным ограничением, поскольку число физических вершин может быть уменьшено без
        влияния на детализацию отображаемого объекта.

        Затраты памяти на хранение информации об отображаемых вершинах зависят от способа вычисления
        их позиций. Если оно выполняется на графическом процессоре, то информация об отображаемых
        вершинах не требуется в~процессе моделирования, и используется только при создании объекта.
        При этом нужно 48 байт на каждую вершину, причём эта память будет освобождена после
        завершения инициализации объекта. Кроме этого, как уже говорилось в п.~\ref{sssec:usage},
        в структуре, используемой в приложении для представления отображаемой вершины, пользователь
        должен выделить место для хранения 8 индексов и их числа. Если число кластеров не больше
        255 (что является разумным ограничением, поскольку это больше типичного числа, приведённого
        в подразделе~\ref{ssec:optimal_parameters}),
        то для хранения индексов и их числа можно использовать 1 байт. Таким образом,
        размер пользовательской структуры увеличивается на 9 байт при использовании вычислений на
        графическом процессоре. Это нужно учитывать, если ресурсы оперативной памяти или памяти
        видеоадаптера уже почти исчерпаны, и такое увеличение затрат недопустимо.

        Если же обновление отображаемой сетки выполняется на центральном процессоре, необходимо
        сохранять информацию обо всех связанных с отображаемой вершиной векторах и точках, а~также об
        ортогональности каждого вектора (необходимость этой информации была объяснена подробнее в
        п.~\ref{sssec:using_gpu}). Допустим, с каждой отображаемой вершиной может быть связано
        не более 5 векторов и 5 точек, тогда размер структуры, представляющей эту вершину в~системе,
        составит 280 байт. Если стоит требование, что максимальное количество памяти, расходуемой на
        графическое представление объекта равно, например, 10 мегабайтам, то число вершин не может
        быть больше \num{35714}. Этого может быть недостаточно для отображения объекта со сложной
        геометрией, поэтому, в отличие от физических вершин, недостаток памяти для хранения
        отображаемых вершин может быть серьёзной проблемой, если обновление их позиций выполняется
        на центральном процессоре.

      \subsubsection{Ограничения графического процессора}

        Число константных регистров вершинного шейдера ограничено. В п.~\ref{sssec:using_gpu} было
        показано, что на каждый кластер требуется 7 таких регистров. Таким образом, число регистров
        вершинного шейдера накладывает ограничение на максимальное возможное число кластеров в
        представлении объекта.

        Например, в графических адаптерах, которые поддерживают спецификацию \eng{Shader Model~4},
        гарантируется наличие \num{65536} таких регистров. Максимальное возможное число
        кластеров при этом равно $\lfloor \num{65536}/7 \rfloor = \num{9362}$. Как было показано
        в~разделе~\ref{sec:results}, это значительно больше оптимального числа кластеров для
        типичного моделируемого объекта. Таким образом, при использовании \eng{Shader Model~4}
        количество регистров не накладывает существенного ограничения на число кластеров. Однако
        версии DirectX 10 и 11, поддерживающие \eng{Shader Model~4}, ещё недостаточно широко
        распространены \cite{steam-hardware}.

        Если же видеоадаптер поддерживает только менее современную спецификацию \eng{Shader
        Model~3}, то гарантированно он имеет только 256 константных регистров вершинного шейдера.
        Поэтому максимальное теоретически возможное число кластеров~--- это $\lfloor 256/7 \rfloor = 36$.
        В~реальности оно ещё меньше, поскольку часть регистров требуется приложению для
        расчётов, связанных с~получением изображения. При использовании данной системы в~режиме
        вычислений на графическом процессоре её пользователь должен учитывать это ограничение и,
        если оно является неприемлемым, использовать режим вычислений на центральном процессоре.

  \section{Дальнейшая работа}

    В дальнейшем планируется работа по ослаблению требований, перечисленных
    в подразделе~\ref{ssec:requirements}. В~частности, описанные там же действия для коррекции
    представления объекта и разбиения на кластеры могут выполняться автоматически.

    Алгоритм имеет довольно много входных параметров, включая разбиение на кластеры и
    различные численные параметры, описанные в подразделе~\ref{ssec:optimal_parameters}. Задание их вручную в коде для каждого
    объекта является неудобным. Планируется разработка программного модуля для редактора
    трёхмерной графики Autodesk 3ds Max, в котором дизайнер сможет удобным способом задавать эти параметры. При этом
    будет разработан собственный формата файла для хранения этих параметров, разбор которого будет
    осуществляться внутри данной системы. Это позволит применять систему в~реальных приложениях
    виртуальной реальности, которые обычно содержат множество разнообразных деформируемых объектов.
    \end{original}

  \section{Conclusion}\label{sec:conclusion}

    \begin{original}
    % TODO Можно цифры ещё сюда
    В данной работе ставилась цель разработать систему моделирования деформаций неупругих тел
    в~реальном времени, ориентированную на применение в~приложениях виртуальной реальности. Эта цель
    была достигнута, и были удовлетворены поставленные в разделе~\ref{sec:task} требования, включая
    высокое быстродействие и удобный для интеграции интерфейс, а~также применение параллельных
    вычислений и отказ от использования предварительно рассчитанных деформаций. Более того,
    использование графического процессора позволило значительно улучшить быстродействие.

    Предусмотрено тестирование системы с~помощью модульных тестов. Также было разработано простое интерактивное
    приложение, использующее возможности системы, чтобы моделировать деформаций предварительно
    заданного объекта. С помощью этого приложения была протестирована правдоподобность деформаций и
    исследованы быстродействие и зависимость характера деформаций от параметров алгоритма.
    При правильном подборе этих параметров система моделирует достаточно реалистичные изображения
    для применения её в приложениях виртуальной реальности.
    Также были исследованы возможности дальнейшего развития и улучшения системы. В частности, планируется разработка
    дополнительных инструментов, упрощающих использование системы разработчиками приложений
    виртуальной реальности.
    \end{original}

  \begin{flushleft}
    \bibliography{../../biblio/my}
  \end{flushleft}
\end{document}

