\documentclass[a4paper, 12pt, titlepage]{extarticle}
  \usepackage{cmap}
  \usepackage[hidelinks,pdftex,unicode]{hyperref}
  \usepackage{mathtext} % для кириллицы в формулах
  \usepackage[T2A]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage[english]{babel}
  \usepackage{indentfirst}
  \usepackage{cite}
  \usepackage{amsmath} % для \eqref
  \usepackage{amssymb} % для \leqslant
  \usepackage{amsthm} % для \pushQED
  \usepackage{color} % пока только для TODO:
  \usepackage[pdftex]{graphicx}
  \usepackage{subfig}
  \usepackage{numprint}
  \usepackage[left=3cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
  \usepackage{datetime}
  \usepackage{comment}
  \usepackage{datetime}
  \graphicspath{{../img/}{../../img/}}
  \frenchspacing

  \DeclareSymbolFont{T2Aletters}{T2A}{cmr}{m}{it} % кириллица в формулах курсивом

  \addto\captionsenglish{
    %\renewcommand\contentsname{Содержание}
    % перекрываю \refname, чтобы список литературы сам добавлял себя в оглавление
    \let\oldrefname\refname
    \renewcommand\refname{\addcontentsline{toc}{section}{\oldrefname}\oldrefname}
  }

  \newcommand{\underscore}[1]{\hbox to#1{\hrulefill}}
  \newcommand{\todo}[1]{\textbf{\textcolor{red}{TODO: #1}}}
  \newcommand{\note}[1]{\textit{Note: #1}}
  \newcommand{\eng}[1]{#1}
  \newcommand{\rus}[1]{{\Russian #1}}

  \specialcomment{original}{%
     \begingroup
     \itshape
     \color{blue}
     %\Russian
  }{
    \endgroup
  }
  \excludecomment{original} % скрывает текст внутри окружения original

  % обёртка с моими настройками поверх figure:
  % \begin{myfigure}{подпись}{fig:label} ... \end{myfigure}
  \newenvironment{myfigure}[2]%
    {\pushQED{\caption{#1} \label{#2}} % push caption & label
     \begin{figure}[!htb]\centering } %
    {  \popQED % pop caption & label
     \end{figure}}

  % вставка картинки: \figure[params]{подпись}{file}
  % создаёт label вида fig:file
  \newcommand{\includefigure}[3][]{
    \begin{myfigure}{#2}{fig:#3}
      \includegraphics[#1]{#3}
    \end{myfigure}
  }

  % вставка subfigure внутри myfigure:
  % \subfigure[params]{подпись}{file}
  \newcommand{\subfigure}[3][]{
    \subfloat[#2]{\label{fig:#3}\includegraphics[#1]{#3}}
  }

  \newcommand{\vect}[1]{\mathbf{#1}} % единое выделение векторов (полужирным)
  \newcommand{\matx}[1]{\mathbf{#1}} % единое выделение матриц (полужирным)
  \newcommand{\transposed}{\top} % единый знак транспонирования (U+22A4 down tack)
  % \renewcommand{\le}{\leqslant} % <= с наклонной нижней перекладиной
  % \renewcommand{\ge}{\geqslant} % >= с наклонной нижней перекладиной

  \linespread{1.0}

  % русские буквы для списков и частей рисунка
  %\renewcommand{\theenumii}{(\asbuk{enumii})}
  %\renewcommand{\labelenumii}{\asbuk{enumii})}
  %\renewcommand{\thesubfigure}{\asbuk{subfigure}}

  %\let\oldsection\section
  %\renewcommand{\section}{\newpage\oldsection}

  \setcounter{tocdepth}{3} % глубина оглавления

  \bibliographystyle{unsrt}

  \hyphenation{англ} % убрать перенос в этом сокращении

  % алиас и настройки для numprint
  \newcommand{\num}[1]{\numprint{#1}}
  \npthousandsep{\,}
  \npthousandthpartsep{}
  \npdecimalsign{,}

  \shortdate
  \newcommand{\checkdate}[3]{(accessed at: \formatdate{#1}{#2}{#3})}

  \newenvironment{firstpage}%
    {\thispagestyle{empty} \begin{center} \large}
    {\end{center} \newpage}

  \author{Ivan Novikov, NSU Physics Department, group 7355}
  \title{A system for modelling plastic deformations of body in real-time}

\begin{document}

%----------------------- титульный лист ------------------------

  \begin{firstpage}
  MINISTRY OF EDUCATION AND SCIENCE

  RUSSIAN FEDERATION

  \vspace{0.3cm}

  NOVOSIBIRSK STATE UNIVERSITY

  \vspace{1.6cm}

  PHYSICS DEPARTMENT

  \vspace {0.5cm}

  AUTOMATION OF PHYSICS AND TECHNICAL RESEARCH CHAIR

  \vspace {5cm}

  Qualification Work on Bachelor Degree

  \vspace {1cm}

  Ivan Novikov, group 7355

  \vspace {1.5cm}

  \textbf{A system for modeling plastic deformations of body in real-time}

  \vspace {1.5cm}

  \begin{flushright}

    Scientific Advisor:

    Dennis Gladky

  \end{flushright}

  \vspace {6cm}

  Novosibirsk 2012
  \end{firstpage}

%------------------------- содержание -------------------------

  \tableofcontents
  \newpage
  \setlength{\parskip}{1ex}

%-------------------------- введение --------------------------
  \section{Introduction}

\begin{original}
    Приложения виртуальной реальности становятся чрезвычайно рас\-прос\-тра\-нён\-ны\-ми в~наши~дни.  Два
    основных их типа~--- это компьютерные игры и~обучающие симуляторы (тренажёры). Несмотря на
    различные применения, эти два типа приложений имеют много общего, поскольку в~обоих случаях
    требуется создать иллюзию присутствия у~пользователя. Для~этого необходимо как генерировать
    фотореалистичные изображения, так и правдоподобно моделировать физику взаимодействия объектов
    виртуального мира: их движение, столкновения, деформации и~разрушение.
\end{original}

    Virtual reality applications become extremely popular nowadays. Two basic types of such
    applications are computer games and training simulators. Despite of different goals, these two
    types of applications have a lot in common, because in both cases it is necessary to create
    illusion of presence. It requires not only to generate photo-realistic images, but also to model
    interactions of virtual world objects (their motion, collisions, deformations and destruction)
    in a verisimilar manner.

\begin{original}
    Моделирование деформаций объектов является актуальной задачей, поскольку кроме приложений
    виртуальной реальности оно находит применение в~системах автоматизированного проектирования, а~также используется
    при~создании спецэффектов к~фильмам. В зависимости от поставленной задачи применяются различные
    подходы. А~именно, в~системах автоматизированного проектирования требуется
    максимальная точность расчётов, в~то~время как в~фильмах и приложениях виртуальной реальности
    требуется лишь визуальная правдоподобность. При~этом, если расчёты для САПР и~спецэффектов могут
    выполняться длительное время, то в~интерактивных приложениях расчёт одного шага вычислений должен
    происходить не~дольше, чем за~промежуток между кадрами, чтобы обеспечивать плавную анимацию
    и отсутствие задержек между воздействием на объект и его деформацией.
\end{original}

    Modeling deformations is a topical problem, since besides virtual reality applications it is
    applied in Computer Aided Design (CAD) systems and for making special effects for motion
    pictures.  Different approaches can be applied depending on task. Namely, CAD systems require
    maximal accuracy of computation, while for films and virtual reality visual plausibility is
    enough. Moreover, while computation for CAD software and special effects may take a long time,
    a~step of computation in interactive applications should take no longer than the interval
    between frames to ensure smooth animation and eliminate lags between interaction with an object
    and its deformation.

\begin{original}
    Жёсткое требование быстродействия в приложениях реального времени не~только вынуждает
    использовать упрощённые физические модели деформации тела, менее точные, чем используемые
    в~инженерных расчётах, но и накладывают существенные ограничения на способ представления
    моделируемого объекта. Чаще всего он задаётся дискретным образом: в~виде сетки, решётки или
    несвязанного набора точек, причём время расчётов напрямую (как~правило, линейно
    \cite{mueller-meshless}) зависит от количества точек в таком представлении. Для отображения
    объектов обычно используют высоко детализированные сетки, содержащие вплоть до нескольких
    сотен тысяч и даже миллионов точек. Это значительно превышает максимальное допустимое число точек для~большинства
    алгоритмов \cite{mueller-stable, mueller-meshless, chang-crash} при расчётах в~реальном времени на
    современных настольных компьютерах и компьютерах, используемых в тренажёрах. Из-за этого
    невозможно использовать одно и~то~же представление объекта и для моделирования, и для
    отображения.
\end{original}

    Severe performance requirements of virtual reality applications not only make developers use
    simplified physical models of deformations, but also significantly limit the way of
    representation of modelled objects. Usually it is represented in a discrete way: as a mesh, a
    grid or a set of unconnected points. The time of computations is directly related (typically,
    linearly \cite{mueller-meshless}) to the number of points in such representation.
    Highly-detailed meshes of hundreds of thousands and even millions of points are commonly used
    for displaying detailed objects, which is far beyond maximum possible number of points for most
    real-time algorithms \cite{mueller-stable, mueller-meshless, chang-crash} if they are applied on
    usual modern personal computers. So it becomes impossible to use the same representation for
    both modeling and displaying of an object.


  \section{Overview of the subject area}\label{sec:domain}

\begin{original}
    Существуют различные подходы к~моделированию деформаций в~реальном времени. В простейшем случае
    ограничения на~быстродействие алгоритма обходятся за счёт использования предварительно рассчитанных
    деформированных состояний для~некоторого конечного набора возможных ударов по~объекту, одно из которых
    (или~интерполяция между несколькими ближайшими) выбирается в~зависимости от~того, к~какому
    из~этих ударов ближе всего произошедший. В~этом случае допускается использование достаточно сложных
    для~вычисления алгоритмов, таких~как система масс и~пружин (англ. \eng{mass-spring system})
    с~большим разрешением или~метод конечных элементов (англ. \eng{finite elements method, FEM}).
    Однако, при ударе, отличающемся от~заранее рассчитанного, или в~случае сложной комбинации ударов
    моделируемые деформации будут выглядеть не реалистично \cite[раздел~2]{chang-crash}. Кроме того, значительное время, требуемое
    для предварительных расчётов после каждого изменения объекта, прежде чем он может быть загружен
    в приложение для тестирования, создаёт неудобства при разработке приложения. Поэтому наибольший
    интерес представляют решения, в которых моделирование деформаций происходит во время исполнения.
\end{original}

    There are different approaches to modeling deformations in real-time. In the simplest case
    performance limitations can be left out by using precomputed deformed states for some restricted
    set of predefined strokes. In real-time, one of these precomputed states (or an interpolation
    between several nearest ones) is chosen depending on which predefined stroke is the most similar
    to happened one. In this case using relatively complex algorithms is allowed, such as
    mass-spring system with high resolution or finite elements method. However, if happened stroke
    differs from predefined ones a lot, or if some complicated combination of strokes takes place,
    then simulated deformation will look unrealistic \cite[section~2]{chang-crash}. Furthermore,
    considerable time required for preliminary computations creates inconveniences in the process of
    development. So the algorithms of simulating deformations at run-time are of the most interest.

\begin{original}
    Одной из~простейших моделей деформируемого тела является упоминавшаяся выше система масс
    и~пружин, в~которой тело представляется в~виде пространственной (как~правило, регулярной и
    кубической) решётки из~материальных точек, которые связаны между~собой пружинами, при~изменении длины
    прикладывающими к~своим концам силу согласно закону Гука. Будучи очень простой в~реализации,
    такая модель, тем не менее, имеет определённые недостатки. Она моделирует поведение объекта не
    очень точно, причём результат сильно зависит от формы решётки и расположения пружин в ней, а так же от
    значений коэффициента упругости каждой отдельной пружины, которые напрямую не связаны с
    реальными свойствами моделируемого материала \cite[п.~3.5.2]{mueller-physmodels}.
    Другим недостатком является то, что возбуждение, приложенное локально, распространяется по
    объекту постепенно, перемещаясь на один шаг решётки за шаг алгоритма \cite[п.~4.4.1]{parent-animation}.
    Кроме~того, требуется выполнять дополнительную работу по конвертации представления объекта,
    используемого для его отображения (чаще всего это неравномерная поверхностная сетка из
    треугольников), в~равномерную объёмную решётку, а также подбирать большое число значений
    коэффициентов упругости пружин так, чтобы добиться требуемых свойств моделируемого материала.
\end{original}

    One of the most simple models of deformable body is the aforementioned mass-spring system.
    A body is represented as a dimensional grid of mass points (usually, regular and cubical),
    which are connected with springs, acting according to Hooke's law. Being very simple for
    implementation, this model, however, has certain drawbacks. It models object behaviour not
    very precise, and the result depends significantly on the grid shape and spring locations, as well as on
    spring constant values of each particular spring, which are not connected directly with real
    properties of modeled material \cite[sec. 3.5.2]{mueller-physmodels}. Another flaw it that an
    excitation applied locally spreads through object slowly, covering one step of the grid at a
    step of the algorithm \cite[sec. 4.4.1]{parent-animation}. Moreover, it requires additional work of converting
    superficial mesh of triangles (a typical representation for 3D objects in software) into regular
    grid and for adjusting spring constants to achieve required properties of modelled material.

\begin{original}
    Принципиально другой подход реализуется в моделях, использующих метод конечных элементов, широко
    применяемый в~инженерных расчётах. При таком подходе
    непрерывные характеристики деформируемого тела вычисляются путём интерполяции их~значений
    на~элементах конечного размера. Разумеется, использовать в чистом виде этот метод
    в приложениях реального времени невозможно, поскольку инженерные расчёты производятся в
    течение нескольких часов и даже суток. Однако, существуют модели, предлагающие различные упрощения этих
    методов, которые допускают вычисление в реальном времени, как, например, в работе~\cite{mueller-stable}.
    Деформации при этом моделируются намного точнее, чем в случае системы масс и пружин, но даже
    упрощённый алгоритм требует больше времени для вычислений. % TODO циферки
\end{original}

    Fundamentally different approach is implemented in the models that use Finite Element Method
    which is widely applied for engineering calculations. In this approach continuous parameters of
    deformable body are found by interpolation of their values over the elements of finite size.
    Naturally, this method cannot be used as it is in virtual reality applications, because
    engineering calculations may last some hours or even days. However, the models exist which
    propose different simplifications of this method, making real-time computation possible.
    Deformations are simulated much more precisely than in the case of mass-spring systems, but even
    a~simplified algorithm requires more time for computation. The~paper \cite{mueller-stable}
    presents an example of such model.

\begin{original}
    Отдельно стоят так~называемые геометрические алгоритмы, в~которых напрямую не~моделируются
    физические законы. Как~правило, объект представляется в~виде системы частиц, движение каждой из
    которых сначала интегрируется независимо от~остальных, а~следующим шагом на объект в~целом
    накладываются различные физически мотивированные ограничения (сохранение формы, объёма, импульса
    и~т.п.), обеспечивающие в итоге правдоподобные деформации. Метод сопоставления формы, один из
    таких геометрических методов, описывается в работе~\cite{mueller-meshless}. Он имеет хорошее быстродействие,
    при этом обладая большей устойчивостью и простотой в конфигурации, чем системы масс и пружин.
\end{original}

    The separate group of methods are formed by so called geometric algorithms. They do not simulate
    laws of physics directly. Generally, the object is represented as a particle system, where
    the movement of each particle is at first integrated regardless of the others. At the next step
    different physically motivated restrictions are applied to the entire object, such as
    conservation of shape, volume, momentum etc. They make resulting deformation look plausible. Shape
    matching method \cite{mueller-meshless} is one of many geometric algorithms. It has a good
    performance while being more stable and configurable than a mass-spring system.

  \section{Problem statement}\label{sec:task}

\begin{original}
    Целью работы является разработка системы моделирования деформаций объектов для применения в
    приложениях виртуальной реальности: в компьютерных играх и обучающих тренажёрах.
    К~системе предъявляются следующие требования.
\end{original}

    The goal of this work is to develop the system for modeling deformation of bodies applicable for
    virtual reality applications: computer games and training simulators. The following requirements
    have to be met.

    \subsection{Requirements}

\begin{original}
    Необходимо использовать сетки из треугольников в качестве внутреннего представления, либо
    предоставить возможность конвертации, поскольку в приложениях виртуальной реальности отображаемые объекты
    чаще всего представляются именно в таком формате. Это связано с~тем, что треугольник является
    одним их основных геометрических примитивов для графических процессоров.~\cite{nvidia-tutorial}
\end{original}

    Triangle meshes should be used as internal representation, otherwise the possibility of conversion from
    such format should be available, because it is a common way of representing visible objects in
    virtual reality applications. That is because triangle is one of the basic geometric primitives
    for graphical processors~\cite{nvidia-tutorial}.

\begin{original}
    Система должна иметь достаточное быстродействие, чтобы обеспечивать моделирование в~реальном
    времени. Известно, что для комфорта пользователя и ощущения им реалистичности моделируемого мира
    приложение виртуальной реальности должно обеспечивать кадровую частоту около 30 кадров в секунду %TODO: кадровую-кадров
    и выше~\cite{claypool-framerate}. Следовательно, все расчёты, необходимые для получения
    следующего кадра, в таком приложения должны занимать не более 33 мс. Поскольку расчёт глобального
    движения и трёхмерной графики обычно является более приоритетной задачей, на вычисление
    деформаций отводится небольшая часть этого времени, около 3-5 мс. Чтобы такое быстрое
    моделирование было возможно даже для~объектов, заданных сеткой с~большим числом вершин,
    должна иметься возможность использовать при~моделировании менее детализированное представление
    объекта, а~отображаемую сетку более высокого разрешения обновлять так, чтобы она повторяла
    рассчитанные деформации. % TODO (В дальнейшую работу?) При~этом важно предусмотреть некоторое сглаживание смещений точек
    % отображаемого объекта, иначе в~их~движении можно будет проследить форму низко детализированного
    % представления.
\end{original}

    The system should be fast enough to provide real-time simulation. A frame rate of 30 frames per
    second or higher is required for the user's comfort and feeling of realism of the simulated
    world~\cite{claypool-framerate}. Therefore, all computations necessary for getting the next
    frame should take less than 33~ms. Since the global motion and 3D-graphics are usually of
    higher priority than deformations, only a little fraction of this time span is given for
    simulating deformations, about 3-5~ms. To make such fast simulation possible even for objects
    defined by a mesh with lots of vertices, there should be a possibility to use less detailed
    representation of the object for simulation. Displayed mesh of higher resolution in this case
    should only be updated to make it repeat already calculated deformation.

\begin{original}
    Для эффективного использования вычислительной мощности многоядерных центральных процессоров,
    получающих в наши дни всё большее распространение~\cite{steam-hardware}, нужно, чтобы вычисления могли
    выполняться параллельно.
\end{original}

    Multi-core central processors become more and more widespread nowadays~\cite{steam-hardware}. In
    order to effectively exploit computational power of such processors the calculations should be
    able to run in parallel.

\begin{original}
    Кроме~того, предварительно рассчитанные деформированные состояния не~должны использоваться,
    поскольку, как было объяснено в разделе~\ref{sec:domain}, такой подход негативно сказывается на реалистичности
    моделирования и создаёт неудобства при разработке приложения.
\end{original}

    In addition, precomputed deformable states should no be used, because this approach adversely
    affects the realism of simulation and creates inconveniences during the development process, as
    it was explained in section~\ref{sec:domain}.

\begin{original}
    Наконец, интерфейс, предоставляемый системой, не~должен создавать трудностей при её интеграции
    в~приложения виртуальной реальности. Основные критерии, которым необходимо следовать,
    описаны в~\cite{gems-middleware} и~включают, в~частности, конфигурируемые обработку ошибок,
    журналирование и~выделение памяти, а также отказ от~прямого доступа к~файловой системе в~пользу
    работы с~буферами в~оперативной памяти. Кроме того, нельзя допускать зависимости от конкретных
    реализаций примитивов синхронизации и функций для работы с потоками, поскольку это может создать
    неудобства, если в приложении используются другие реализации.
\end{original}

    Finally, the interface of the system should not create difficulties during its integration into
    virtual reality applications. The application which the system is integrated into is further called
    the \emph{host application}. The basic criteria to be followed are described in~\cite{gems-middleware}.
    They include, in particular, configurable error handling, logging and memory management, as well
    as refusing from direct access to file systems in favour of working with in-memory buffers.
    Moreover, dependence on specific implementations of synchronization primitives and thread
    manipulation functions should not be allowed, because it might create problems if the
    application uses different implementation.

    \subsection{Objectives}

\begin{original}
    Для достижения цели необходимо решить следующие задачи:
    \begin{enumerate}
      \item Разработать и~реализовать алгоритм моделирования в реальном времени деформаций
        не\-у\-пру\-гих тел, содержащих недеформируемые части.
      \item Предоставить интерфейс для~двустороннего взаимодействия с~приложением, в~которое будет
        встроена система, включающий:
        \begin{enumerate}
          \item конвертацию представления объекта, используемого в приложении, во внутреннее представление;
          \item получение извне информации о~столкновениях объекта и~приложенных к~нему силах;
          \item уведомление о событиях, произошедших в процессе деформации;
          \item обновление отображаемой сетки.
        \end{enumerate}
      \item Предусмотреть возможность использования параллельных вычислений.
    \end{enumerate}
\end{original}

    In order to achieve the goal of this work the following objectives should be completed:
    \begin{enumerate}
      \item To develop and implement a real-time algorithm for modelling plastic deformations of bodies
        containing undeformable parts.
      \item To implement an interface for two-way communication with the host application, including:
        \begin{enumerate}
          \item conversion of the object representation used in the host application into internal representation;
          \item obtaining the information about collisions with the object and the forces applied to it;
          \item notifying the host application about the events happened during deformation
          \item updating the displayed mesh.
        \end{enumerate}
      \item To provide support for using parallel computing.
    \end{enumerate}

  \section{Modeling deformation}

\begin{original}
    В этом разделе рассматриваются методы, используемые для решения поставленных задач. Описан выбор
    основного алгоритма для моделирования деформаций неупругих тел, сделанные в~нём изменения,
    а~также реализация дополнительных функций и применение параллельных вычислений.
\end{original}

    In this section the methods are considered which are used for solving the stated problem. Described are
    the main algorithm chosen for modeling plastic deformations of bodies, the improvements that were
    made to it, as well as the implementation of additional features and the use of parallel computing.

    \subsection{Basic algorithm}\label{ssec:basic_algorithm}

\begin{original}
      В разделе~\ref{sec:domain} были рассмотрены различные подходы к моделированию деформаций:
      система масс и пружин, упрощённый метод конечных элементов и геометрический метод
      сопоставления формы. В~частности, было показано, что использование системы масс и пружин
      связано с~необходимостью существенного преобразования формата объекта и подбора большого числа
      коэффициентов, напрямую не определяемых свойствами материала. Упрощённый метод конечных
      элементов, в свою очередь, оперирует реальными непрерывными характеристиками материала, и
      за~счёт этого моделирует деформации очень реалистично, но имеет плохое быстродействие. Поэтому
      в~данной работе выбор был сделан в пользу метода сопоставления формы, предложенного в
      работе~\cite{mueller-meshless}. Он работает значительно быстрее, но, чтобы моделирование было
      реалистичным, нужно в каждом конкретном случае правильно подобрать параметры. Впрочем, число
      этих параметров меньше, чем в случае метода масс и пружин. Далее описан исходный алгоритм и
      изменения, которые были сделаны для его адаптации к текущей задаче.
\end{original}

      In the section~\ref{sec:domain} different approaches to modelling deformations were
      considered. They include a~mass-spring system, a~simplified finite elements method and
      a~geometric method of shape matching. In particular, it was shown that using mass-spring
      systems is concerned with the need for considerable transformation of object format and for
      selection of many coefficients which are not derived directly from the properties of the
      modelled material. A simplified finite element method, on the contrary, operates real
      continuous properties of the material and thus simulates deformations in a very realistic way,
      but it is not fast enough. That is why in this work the choice was made in favor of shape
      matching method proposed in~\cite{mueller-meshless}. It works much faster but in order to make
      simulation realistic it is necessary to correctly adjust parameters for each particular case.
      Nevertheless, the number of these parameters is less than in case of a mass-spring system.
      Described below are the original algorithm of shape matching and the changes made to adapt it
      for current task.

      \subsubsection{Original algorithm}\label{sssec:original_algorithm}

\begin{original}
        \paragraph{Входные данные и результат.} Объект представляется в~виде набора точек,
        сгруппированных в~перекрывающиеся множества, называемые кластерами
        (информация о~связях между вершинами, то~есть об~образуемых ими полигонах, не требуется).
        На~вход алгоритма поступает заданный таким образом объект, а так же информация о~приложенных
        силах. Задаётся величина шага по времени. Результатом выполнения одной итерации алгоритма
        являются позиции точек, задающих объект, в следующий момент времени.
\end{original}

        \paragraph{Input and output.} An object is represented by an array of points, grouped into
        overlapping sets here called \emph{clusters}. Therefore, the information about connections between
        vertices is not required. An object represented this way is given to the algorithm as the
        input, as well as the information about applied forces. Time step value is set. The results
        of single iteration of algorithm are positions of points representing object at the next
        instant of time.

\begin{original}
        \paragraph{Общая схема алгоритма.} Скорости и позиции этих материальных точек интегрируются независимо
        друг от друга, для чего используется явная схема Эйлера. Затем над каждым кластером
        производится операция сопоставления формы: вычисляется новое положение центра масс кластера
        и оптимальное линейное преобразование $\matx A$, действие которого переводит исходную форму
        кластера в~наиболее близкую к~текущей форме. Пусть $\vect{x}^0_i$ и $\vect{x}_i$~---
        соответственно исходная и текущая позиция $i$-й точки,
        $\vect{x}^0_{ц.м.}$ и $\vect{x}_{ц.м.}$~--- исходный и текущий центр масс кластера. Введём
        $\vect{q}_i = \vect{x}^0_i - \vect{x}^0_{ц.м.}$,
        $\vect{p}_i = \vect{x}_i - \vect{x}_{ц.м.}$~--- исходное и текущее положение точки
        относительно центра масс кластера. Эти относительные позиции и будут сравниваться при
        сопоставлении формы. В качестве критерия оптимальности для преобразования $\matx A$
        используется сумма квадратов отклонений начальных позиций, преобразованных его действием, от текущих:
        $\sum_i m_i (\matx A \vect{q}_i - \vect{p}_i )^2$. В работе~\cite{mueller-meshless} было
        показано, что эта величины достигает минимума, если
        \begin{equation}
          \matx A = \left( \sum_i m_i \vect{p}_i \vect{q}_i^\transposed \right)
                    \left( \sum_i m_i \vect{q}_i \vect{q}_i^\transposed \right)^{-1}.
        \end{equation}
\end{original}

        \paragraph{General scheme of the algorithm.} Velocities and positions of these mass-points
        are integrated regardless of each other using the explicit Euler method. Then each cluster is
        subjected to shape matching operation: a new position of the center of mass of the cluster
        is found, as well as an optimal linear transformation $\matx A$ which converts the initial
        shape of the cluster into the closest to the current shape. Let $\vect{x}^0_i$ and
        $\vect{x}_i$ be the initial and the current position of $i^{th}$ point; $\vect{x}^0_{c.m.}$
        and $\vect{x}_{c.m.}$ be the initial and the current center of mass of the cluster. By
        $\vect{q}_i = \vect{x}^0_i - \vect{x}^0_{c.m.}$ and $\vect{p}_i = \vect{x}_i -
        \vect{x}_{c.m.}$ denote the initial and the current offset of point relative to the center
        of mass of the cluster. As a criteria of optimality for the transformation $\matx A$ used is
        the sum of squared differences between transformed initial positions and current positions:
        $\sum_i m_i (\matx A \vect{q}_i - \vect{p}_i )^2$. It was shown in~\cite{mueller-meshless}
        that this term is minimized when
        \begin{equation}
          \matx A = \left( \sum_i m_i \vect{p}_i \vect{q}_i^\transposed \right)
                    \left( \sum_i m_i \vect{q}_i \vect{q}_i^\transposed \right)^{-1}.
        \end{equation}

\begin{original}
        После того как оптимальное преобразование $\matx A$ найдено, для каждой точки определяется
        положение, которое она имела бы, если бы изменение формы кластера в~точности определялось этим
        преобразованием, с~учётом смещения центра масс:
        \begin{equation}
          \vect{g}_i = \matx{A} (\vect{x}^0_i - \vect{x}^0_{ц.м.}) + \vect{x}_{ц.м.}.
        \end{equation}
\end{original}

        Once the optimal transformation $\matx A$ of the cluster is found, the goal position is
        calculated for each point which belongs to it. The \emph{goal position} of a point is a
        position which it would have if the change of cluster's shape was defined exactly by the
        transformation $\matx A$. The change of the center of mass is also taken into account:
        \begin{equation}
          \vect{g}_i = \matx{A} (\vect{x}^0_i - \vect{x}^0_{c.m.}) + \vect{x}_{c.m.}.
        \end{equation}

\begin{original}
        Далее $\vect{g}_i$ называется целевой позицией точки. Для каждой точки, исходя из величины
        отклонения её текущей позиции от~целевой, рассчитывается поправка к~скорости, корректирующая
        это отклонение. Если точка входит одновременно в~несколько кластеров, то~есть находится
        в~зоне их перекрытия, корректирующие поправки от~каждого из~кластеров усредняются, что
        обеспечивает целостность объекта: за~счёт этого кластеры, обрабатываемые независимо,
        не~отделяются друг от~друга.
\end{original}

        For each point of the cluster an amendment to its velocity is calculated which corrects the
        deviation of the current position from the goal position. If the point is included in more
        than one cluster (that is, belongs to their intersection) then the amendments from different
        clusters are averaged. This ensures integrity of the object: due to that fact the clusters
        do not separate from each other although they are handled independently.

\begin{original}
        \paragraph{Остаточная деформация.} Для моделирования неупругости остаточная деформация
        каждого кластера сохраняется в~форме линейного преобразования $\matx{S}^{ост}$, то~есть
        матрицы $3 \times 3$. Изначально она единичная, а~изменение происходит, лишь когда мера
        текущей деформации превышает заданную пороговую величину $d_{неупр}$. В~качестве такой меры может быть
        использована $ \|\matx S - \matx E\|_2 $, где $\matx S$~--- симметричная компонента $\matx
        A$, $\matx E$~--- единичная матрица, норма Фробениуса $\|\matx M\|_2 = \sqrt{\sum_{i, j} |m_{ij}|^2}$.
        Симметричная матрица $\matx S$ получается при полярном разложении матрицы $\matx A$:
        \begin{equation}
          \matx A = \matx R \matx S,
        \end{equation}
        где $\matx R$~--- ортогональная матрица. Выбор именно симметричной компоненты обусловлен
        тем, что в неё не входят вращения, которые не изменят форму и потому не должны учитываться.
        Когда описанная мера превышает $d_{неупр}$, матрица $\matx{S}^{ост}$ должна измениться,
        сохранив часть текущей деформации:
        \begin{equation}
          \matx{S}^{ост} = \left(E + u \Delta t (\matx S - \matx E) \right) \matx{S}^{ост},
        \end{equation}
        здесь $\Delta t$~--- шаг по времени, а параметр $u$ характеризует скорость изменения
        остаточной деформации. Максимальная остаточная деформация ограничена: когда
        $\|\matx{S}^{ост} - \matx E\|_2$ достигает предельной величины $d_{max}$, матрица
        $\matx{S}^{ост}$ перестаёт изменяться. Остаточная деформация учитывается затем при
        сопоставлении формы и расчёте целевых позиций. А именно, исходные позиции перед сравнением
        с текущими при сопоставлении формы, преобразуются матрицей $\matx{S}^{ост}$. Таким
        образом, сопоставление происходит не с~исходной, а с деформированной формой. Кроме того, формула для
        расчёта целевых позиций принимает следующий вид:
        \begin{equation}
          \vect{g}_i = \matx{A} \matx{S}^{ост} (\vect{x}^0_i - \vect{x}^0_{ц.м.}) + \vect{x}_{ц.м.}.
        \end{equation}
\end{original}

        \paragraph{Residual deformation.} To simulate inelasticity the residual deformation of each
        cluster is saved in the form of a linear transformation $\matx{S,}^{\!\!res}$ that is, in the
        form of a $3 \times 3$ matrix. Initially, it is a unity matrix and it is changed only when
        the measure of deformation exceeds a predefined threshold value $d_{inelast}$. A possible
        measure of deformation is $ \|\matx S - \matx E\|_2 $, where $\matx S$ is a symmetric
        component of $\matx A$, $\matx E$ is a unity matrix, and the matrix norm is the Frobenius
        norm which is defined as follows: $\|\matx M\|_2 = \sqrt{\sum_{i, j} |m_{ij}|^2}$. The
        symmetric matrix $\matx S$ is obtained via polar decomposition of the matrix $\matx A$:
        \begin{equation}\label{eq:polar_decomposition}
          \matx A = \matx R \matx S,
        \end{equation}
        where $\matx R$ is an orthogonal matrix. The choice of symmetric component is determined by
        the fact that it doesn't include rotations. Rotations do not change the shape and thus should
        not be considered in the measure of deformation. When the described measure exceeds $d_{inelast}$
        the matrix $\matx{S}^{res}$ should be updated in order to save a portion of current deformation:
        \begin{equation}
          \matx{S}^{res} = \left(E + u \Delta t (\matx S - \matx E) \right) \matx{S}^{res}.
        \end{equation}
        Here $\Delta t$ is a time step, and $u$ is a parameter describing how fast residual
        deformation is changed. Maximum residual deformation is limited: when
        $\|\matx{S}^{res} - \matx E\|_2$ reaches extreme value of $d_{max}$ the matrix
        $\matx{S}^{res}$ ceases to change. Residual deformation is then taken into account during
        shape matching and computing goal positions. To be exact, initial positions are transformed
        by the matrix $\matx{S}^{res}$ before they are compared to current positions. Thus
        matching is made to deformed shape instead of the initial one. Besides, the formula for goal
        positions becomes as follows:
        \begin{equation}\label{eq:goal_pos}
          \vect{g}_i = \matx{A} \matx{S}^{res} (\vect{x}^0_i - \vect{x}^0_{c.m.}) + \vect{x}_{c.m.}.
        \end{equation}

      \subsubsection{Proposed changes of algorithm}\label{sssec:proposed_changes}

\begin{original}
        В~исходный алгоритм вносятся изменения, адаптирующие его к~условиям данной
        задачи. Во-первых, моделирование неупругих тел требует демпфирования возникающих колебаний.
        Во-вторых, система отвечает только за~моделирование деформаций, а глобальное движение и
        определение столкновений рассчитываются отдельно приложением, в~которое встроена система.
        Поэтому расчёт деформаций необходимо производить в~локальных координатах~---
        в~неинерциальной системе отсчёта, связанной с центром масс объекта, в которой он не
        движется и не вращается. Далее для краткости она называется системой центра масс.
\end{original}

        The changes are made to the basic algorithm in order to adapt it to the current conditions.
        First, simulation of inelastic bodies requires damping of arising oscillations. Second, the
        system is responsible for modeling deformations only, while the global motion and collision
        detection are computed separately in the host application. Consequently, the computation of
        deformations should be made in local coordinates: in a non-inertial reference frame
        associated with the center of mass of the object where it neither move or rotate. Further
        this reference frame is called the \emph{center-of-momentum frame} for short.

\begin{original}
        \paragraph{Демпфирование.} Чтобы поведение неупругого тела выглядело правдоподобно,
        нужно, чтобы затухали только колебания, а глобальное движение тела сохраняло свои характеристики.
        Для этого используется способ, описанный в~\cite[подраздел~3.5]{mueller-position-dynamics}. Сначала выделяется
        движение тела как~целого~--- вычисляются скорость центра масс $\vect{v}_{ц.м.}$ и угловая
        скорость $\vect{\omega}$. Для этого находятся центр масс
        $\vect{x}_{ц.м.}$ и тензор инерции $\matx I$ (матрица $3 \times 3$):
        \begin{eqnarray*}
          \vect{x}_{ц.м.} & = & \frac{\sum_i m_i \vect{x_i}}{\sum_i m_i},\\
          \vect{r}_i      & = & \vect{x}_i - \vect{x}_{ц.м.},\\
          \matx{I}        & = & \sum_i m_i ( |\vect{r}_i|^2 \matx E - \vect{r}_i \vect{r}_i^\transposed),\\
        \end{eqnarray*}
        где $\matx E$~--- единичная матрица $3 \times 3$. Затем вычисляются
        \begin{eqnarray*}
          \vect{v}_{ц.м.} & = & \frac{\sum_i m_i \vect{v_i}}{\sum_i m_i},\\
          \vect{L}        & = & \sum_i \vect{r}_i \times (m_i \vect{v}_i),\\
          \vect{\omega}   & = & \matx{I}^{-1} \vect{L}.
        \end{eqnarray*}
        Для каждой вершины определяется скорость,
        которую она имела~бы, если~бы тело было абсолютно твёрдым:
        \begin{equation}
          \vect{u}_i = v_{ц.м.} + \omega \times (\vect{x}_i - \vect{x}_{ц.м.}).
        \end{equation}
        Демпфированию подвергается только индивидуальное отклонение скорости вершины
        $\Delta \vect{v}_i = \vect{v}_i - \vect{u}_i$:
        \begin{equation}
          \vect{v}_i = \vect{v}_i - k \Delta \vect{v}_i,
        \end{equation}
        где $k \in [0, 1]$. За счёт этого $\vect{v}_{ц.м.}$ и $\vect{\omega}$ сохраняются.
\end{original}

        \paragraph{Damping.}
        In order that the behavior of inelastic body looks plausible it is necessary that only
        oscillations are damped while global motion conserves its parameters. Used here is the
        method described in~\cite[sec.~3.5]{mueller-position-dynamics}. At first the motion of the
        body as a whole is singled out: the velocity of the center of mass $\vect{v}_{c.m}$ and the
        angular velocity $\vect{\omega}$ are computed. In order to do this the center of mass
        $\vect{x}_{c.m.}$ and the moment of inertia tensor $\matx I$ (a $3 \times 3$ matrix) are found:
        \begin{eqnarray*}
          \vect{x}_{c.m.} & = & \frac{\sum_i m_i \vect{x_i}}{\sum_i m_i},\\
          \vect{r}_i      & = & \vect{x}_i - \vect{x}_{c.m.},\\
          \matx{I}        & = & \sum_i m_i ( |\vect{r}_i|^2 \matx E - \vect{r}_i \vect{r}_i^\transposed),\\
        \end{eqnarray*}
        where $\matx E$ is a $3 \times 3$ unity matrix. Then the mentioned velocities are computed:
        \begin{eqnarray*}
          \vect{v}_{c.m.} & = & \frac{\sum_i m_i \vect{v_i}}{\sum_i m_i},\\
          \vect{L}        & = & \sum_i \vect{r}_i \times (m_i \vect{v}_i),\\
          \vect{\omega}   & = & \matx{I}^{-1} \vect{L}.
        \end{eqnarray*}
        For each vertex computed is the velocity which it would have if the body was absolutely rigid:
        \begin{equation}\label{eq:rigid_velocity}
          \vect{u}_i = v_{c.m.} + \omega \times (\vect{x}_i - \vect{x}_{c.m.}).
        \end{equation}
        Only individual deviations of vertex velocity $\Delta \vect{v}_i = \vect{v}_i - \vect{u}_i$
        are subjected to damping:
        \begin{equation}\label{eq:damping}
          \vect{v}_i = \vect{v}_i - k \Delta \vect{v}_i,
        \end{equation}
        where $k \in [0, 1]$. Therefore, $\vect{v}_{c.m.}$ and $\vect{\omega}$ are conserved as necessary.

\begin{original}
        \paragraph{Расчёт в локальных координатах.} Проблема, возникающая при расчёте деформаций в
        системе центра масс, заключается в том, что вследствие удара или воздействия внешних сил
        у~тела может появиться как ненулевая скорость центра масс, так и ненулевая угловая скорость.
        Таким образом, система отсчёта, в~которой производится расчёт, перестанет быть системой центра
        масс. Поэтому после интегрирования скоростей и до интегрирования позиций вершин производится
        коррекция. Приобретённые на данном шаге $\vect{v}_{ц.м.}$ и $\vect{\omega}$ уже получены
        в~ходе расчёта демпфирования. Чтобы локальная система отсчёта снова стала системой центра масс,
        необходимо скомпенсировать их, вычитая из скорости каждой вершины $\vect{u}_i$ из \eqref{eq:rigid_velocity}.
        После этого приложение, в которое встроена система, должно получить из неё значения
        $\vect{v}_{ц.м.}$ и $\vect{\omega}$ и скорректировать глобальное движение объекта, прибавив их
        к его линейной и угловой скоростям соответственно.
\end{original}

        \paragraph{Computing in local coordinates.} The problem which appears when deformations are
        computed in the center-of-momentum frame is as following. As a result of a stroke or
        external forces effect, a non-zero velocity of the center of mass of body may appear, as well as
        non-zero angular velocity. Thus the named reference frame will no longer be the
        center-of-momentum frame. That is why the correction is made after integrating velocities
        and before integrating positions of vertices. $\vect{v}_{c.m.}$ and $\vect{\omega}$ acquired
        during the present step are already calculated during the computation of damping. In order to
        return back to the center-of-momentum frame again it is required to compensate these
        velocities. It is done by subtracting $\vect{u}_i$ defined in \eqref{eq:rigid_velocity} from
        the velocity of $i^{th}$ vertex, consequently for each vertex. After that the host
        application should get the values of $\vect{v}_{c.m.}$ and $\vect{\omega}$ and correct the
        global motion of the object by adding them to its linear and angular velocities, correspondingly.

    \subsection{Implementation of additional features}

\begin{original}
      Как уже говорилось в разделе~\ref{sec:task}, кроме собственно моделирования деформаций, ядро
      системы предоставляет дополнительную функциональность, а именно, поддержку недеформируемых
      частей, получение информации о произошедших столкновениях и приложенных силах, обнаружение
      определённых событий и обновление отображаемой сетки. Предлагаемые способы
      реализации этих функций описаны далее.
\end{original}

      As it was already mentioned in section~\ref{sec:task}, the core of the system provides
      an additional functionality besides modelling deformation. This includes support for
      undeformable parts, obtaining information about happened collisions and applied forces,
      detection of certain events and updating the displayed mesh. Proposed means of implementation
      of these functions are described below.

      \subsubsection{Support for undeformable parts}

\begin{original}
        Имеется возможность задать множество вершин, сохраняющее свою форму~--- недеформируемую раму.
        Чтобы обеспечить это, используется та~же техника, что и в~алгоритме демпфирования,
        описанном в п.~\ref{sssec:proposed_changes}, только коэффициент $k$ в~\eqref{eq:damping}
        берётся равным единице, то~есть индивидуальные отклонения скоростей $\Delta \vect{v}_i$
        подавляются полностью. Это действие необходимо также производить на каждом шаге, после
        интегрирования скоростей, но до~демпфирования, иначе из-за порождённых колебаний система
        может стать нестабильной.
\end{original}

        It is required to provide the ability to define a set of vertices which saves its shape:
        a~\emph{rigid frame}. The same technique is used here as in the damping algorithm described
        in sec.~\ref{sssec:proposed_changes}. The only difference is that the factor $k$
        in~\eqref{eq:damping} is assumed to be equal to 1. That is, the individual deviations of
        velocities are suppressed completely. This action should also be done at each step after
        integrating velocities but before damping. Otherwise the simulation may become unstable due
        to the oscillations caused by this interference.

      \subsubsection{Obtaining information about external actions}\label{sssec:external_forces}

\begin{original}
        Деформация объекта происходит по причине внешних воздействий на него, наиболее интересными
        из которых являются столкновения~--- они и приводят к наибольшим деформациям. Количественно
        столкновение может быть задано как~в виде силы, действующей в~течение определённого времени, так и
        в~виде мгновенно сообщаемого объекту изменения импульса.
        Система поддерживает оба формата, что позволяет интегрировать её в приложение независимо от
        того, какой способ задания столкновений в~нём используется.
        Любое внешнее воздействие оказывается локально, поэтому необходимо также указать область,
        в~которой оно действует.
\end{original}

        Deformation of the object is caused by external actions, collisions being the most
        interesting of them, since they cause the most strong deformation. Quantitatively the
        collision may be defined either as a force acting during definite short time span, or as a
        change of momentum which is imparted instantly to the object. The system supports both
        formats thus being applicable independent on the variant used in the host application. Any
        external action is local, so in both cases the region of the action is also indicated.

      \subsubsection{Detecting events}\label{sssec:events}

\begin{original}
        Следствием деформации объекта в~приложениях виртуальной реальности является не только
        изменение формы его отображаемой модели. Типичные события и их последствия могут быть
        наглядно продемонстрированы на примере автомобильного симулятора. Хрупкие объекты, такие как
        стёкла и зеркала, должны разрушаться при прямом ударе или значительном изменении формы их
        рамы. Двигатель должен перестать работать при сильной деформации кузова около него.
        Наконец, автомобиль должен замедлиться, если кузов деформирован настолько, что задевает
        дорогу. Таким образом, требуется, чтобы система моделирования деформаций обнаруживала
        происходящие события и сообщала о них. Данная система может обнаружить следующие события:
        \begin{enumerate}
          \item Удар в~заданною область, превышающий по~силе заданный порог.
          \item Отклонение некоторой точки объекта от~начальной формы больше заданного предела
          (сильная локальная деформация).
          \item Вход некоторой точки в~заданную область (или выход из~неё).
        \end{enumerate}
        Способ обнаружения каждого из событий описан далее. Интерфейс для уведомления об
        обнаруженном событии рассматривается в п.~\ref{sssec:reactions}.
\end{original}

        Change of shape of the object is not the only result of deformation of an object in a
        virtual reality application. Typical events and their consequences may be illustrated by the
        example of an automobile simulator. Fragile objects such as windows and mirrors should be
        destroyed in case of a direct stroke or a significant change of their shape. An engine
        should stop working after a serious deformation of the body around it. Finally, an
        automobile should slow down if the body is so much deformed that it touches the road.
        Thus the system for modelling deformations should detect happening events and notify the
        host application about them. This system can detect the following events:
        \begin{enumerate}
          \item A stroke into a particular area which is stronger than a predefined threshold.
          \item A strong local deformation: a deviation of position of some point of the object from
                the initial shape which is more than a predefined threshold.
          \item Entering predefined area by some point of the object (or leaving).
        \end{enumerate}
        The ways of detection of each type events are explained below.

\begin{original}
        \paragraph{Удар в заданную область.}
        Простейшее событие~--- это удар в некоторую область, заданную массивом индексов
        входящих в~неё вершин. Для его определения нужно лишь проверить, входит ли хоть одна из этих
        вершин в~зону действия удара и превышает~ли изменение её скорости пороговую величину.
\end{original}

        \paragraph{A stroke into a given area.}
        The simplest kind of event is a stroke into some area. To detect this event it is only
        required to check whether at least one of these vertices belongs to this area and whether
        the change of absolute value of its velocity exceeds the threshold value.

\begin{original}
        \paragraph{Отклонение от начальной формы.}
        Для определения таких событий необходимо отдельно хранить начальную позицию каждой вершины.
        То, что вычисления производятся в~системе центра масс, упрощает определение
        отклонения. За~счёт того, что постоянные смещения и повороты, не~являющиеся деформациями,
        автоматически исключаются, отклонение может быть вычислено просто как разность текущей и
        начальной позиции.
\end{original}

        \paragraph{Deviation from initial shape.}
        In order to detect such events it is necessary to store initial position of every vertex.
        Performing computations in the center-of-momentum frame simplifies detection of the deviation.
        Due to the fact that such false deformations as shifts and rotations are automatically
        eliminated, the deviation can be found simply as the difference between the current and the
        initial positions.

\begin{original}
        Однако при наличии жёсткой рамы эта разность уже не характеризует деформацию. Рама может
        двигаться относительно центра масс, и её вершины при этом будут иметь ненулевое отклонение
        от начальных позиций. Но на~самом деле форма рамы не~изменилась, так что считать, что событие
        произошло, в~этом случае неверно. Чтобы исключить такие ложные события, необходимо определить смещение и поворот
        рамы в~системе центра масс относительно начального положения. Если перед сравнением позиции
        вершины с~её начальной позицией вычесть это смещение и поворот, то позиции вершин рамы
        всегда будет совпадать с~начальными. Смещение и поворот можно определить, интегрируя на
        каждом шаге линейную и угловую скорость рамы. Но для того, чтобы <<вычесть>> поворот,
        необходимо обратить матрицу поворота (для чего её достаточно транспонировать, так~как она
        ортогональна). Чтобы не делать этого на каждом шаге алгоритма, можно просто интегрировать угловую
        скорость с~противоположным знаком.
\end{original}

        However, in case of presence of a rigid frame this difference doesn't describe the
        deformation well. The rigid frame may move relative to the center of mass, and in this case
        its vertices may have non-zero deviation from initial positions. In fact, the shape of the
        frame is not changed anyway, so it is not correct to assume that an event of deviation from
        initial shape happened. In order to eliminate such false detections it is necessary to
        determine the shift and the rotation of the rigid frame relative to the center-of-momentum
        frame.  If these shift and rotation are subtracted from the position of a vertex before
        comparing to the initial position, then the positions of vertices forming the rigid frame
        will be always equal to their initial positions. The shift and the rotation are found by
        integrating linear and angular velocities of the rigid frame at each step. But in order to
        ``subtract'' the rotation we need to invert the rotation matrix (i.e. transpose it, since it
        is orthogonal). To avoid doing it at each step the vector of angular velocity can simply be
        inverted during its integration.

\begin{original}
        \paragraph{Вход в~заданную область.}
        Координаты, в которых задана область, логично связать с~неподвижной рамой. Для этого, как и
        в~случае с определением отклонения от начальной формы, описанным выше, перед проверкой на принадлежность
        области необходимо подвергнуть позицию вершины смещению и повороту, обратным к смещению и
        повороту рамы.
\end{original}

        \paragraph{Entering a predefined area.}
        It is logical to define the area in the coordinate system associated with the undeformable
        frame. To do this the same method is used as to detect a deviation from initial shape which
        is described above. Before testing vertex position for belonging to the area it should be
        subjected to the shift and the rotation inverse to those of the rigid frame.

      \subsubsection{Support for high-polygonal meshes}\label{sssec:hi-poly}

\begin{original}
        \paragraph{Преобразование позиций.}
        Отображение деформаций низкополигональной физической модели объекта на высокополигональную
        отображаемую сетку реализуется с~использованием того, что остаточная деформация кластера и
        его текущее состояние хранятся в~нём в~виде матриц.  Для этого необходимо каждую вершину
        высокополигональной сетки также связать с~одним или несколькими кластерами и сохранить её
        исходную позицию. В~каждом кластере её новая позиция рассчитывается аналогично целевым
        позициям в \eqref{eq:goal_pos}. Здесь вместо матрицы оптимального линейного преобразования
        $\matx A$ можно использовать её ортогональную компоненту $\matx R$, характеризующую
        оптимальное вращение, чтобы сильные изменения формы физической модели не отражались на
        отображаемой сетке:
        \begin{equation}\
          \vect{x}'_i = \matx{R} \matx{S}^{ост} (\vect{x}^0_i - \vect{x}^0_{ц.м.}) + \vect{x}_{ц.м.}.
        \end{equation}
        В случае если вершина входит в несколько кластеров, позиции, рассчитанные по этой формуле
        для каждого из них, должны быть усреднены. Полученная в результате позиция и будет позицией
        вершины в деформированной отображаемой сетке.
\end{original}

        \paragraph{Transforming positions.}
        Mapping deformation of the low-polygonal physical model of an object onto the high-polygonal
        displayed mesh is done using the fact that residual deformation of every cluster and its
        current state is stored in the form of a matrix. Thus each vertex of high-polygonal mesh
        should be also associated with one or more clusters and its initial position should be
        stored. In each cluster its new position is calculated the same way as the goal position
        in~\eqref{eq:goal_pos}. Here the orthogonal component $\matx R$ of the matrix $\matx A$ can
        be used instead the matrix $\matx A$ itself in order to prevent serious changes of the shape
        of physical model from transferring onto the displayed mesh:
        \begin{equation}\label{eq:graphical_pos}
          \vect{x}'_i = \matx{R} \matx{S}^{res} (\vect{x}^0_i - \vect{x}^0_{c.m.}) + \vect{x}_{c.m.}.
        \end{equation}
        If the vertex is included into more than one cluster, then the positions obtained from this
        formula for each of them should be averaged. Resulting position is the desired new position
        of the vertex of the deformed visible mesh.

\begin{original}
        \paragraph{Преобразование векторов.}
        Кроме позиции вершина высокополигональной сетки обычно также содержит некоторые связанные векторы:
        например, нормаль к поверхности в данной точке, требующуюся при расчёте освещения, или
        тангенциальный базис для бамп-мэппинга (англ. \eng{bump-mapping}, \cite{blinn-bump}). Их тоже необходимо
        преобразовывать, причём векторы, параллельные поверхности, преобразуются не так, как
        перпендикулярные ей. Параллельный поверхности вектор может быть представлен как разность двух
        принадлежащих касательной плоскости точек, причём если взять их достаточно близкими друг
        к~другу, то можно считать, что они обе лежат на поверхности, и, следовательно, их разность
        преобразуется так же, как и точки поверхности.
\end{original}

        \paragraph{Transforming vectors.}
        Besides its position a vertex of high-polygonal mesh usually has some vectors associated
        with it. Examples are the normal to the surface required for lighting computation and
        tangential basis for bump-mapping~\cite{blinn-bump}. They also have to be transformed after
        deformations. The vectors parallel to the surface and those normal to it are transformed in
        different ways. A parallel vector can be represented as a difference of two points belonging
        to the tangential plane. If these points are close to each other they both may be assumed to
        belong the surface. Therefore, their difference is transformed the same way as the surface
        itself. In other words, the same matrix should be used for transforming parallel vectors as
        for transforming positions.

\begin{original}
        Нормаль же преобразуется иначе. Пусть $\vect n$~---
        нормаль, тогда касательная плоскость в~точке $\vect{x}_0$ описывается уравнением
        \[
        \vect{n}^\transposed (\vect x - \vect{x}_0) = 0.
        \]
        Пусть точки касательной плоскости преобразуются матрицей $\matx M$, тогда, учитывая, что
        $\matx{M}^{-1} \matx{M} = \matx{E}$, уравнение плоскости преобразуется к~виду
        \[
          \vect{n}^\transposed \matx{M}^{-1} \matx{M} (\vect x - \vect{x}_0) = 0,
        \]
        что эквивалентно
        \[
           \left( (\matx{M}^{-1})^\transposed \vect{n} \right)^\transposed (\matx{M} \vect x - \matx{M} \vect{x}_0) = 0.
        \]
        Отсюда следует, что $(\matx{M}^{-1})^\transposed \vect{n}$ является нормалью к преобразованной
        матрицей $\matx M$ касательной плоскости. Итак, перпендикулярные поверхности векторы
        преобразуются транспонированной обратной матрицей к матрице, которой преобразуются позиции
        вершин и векторы, параллельные поверхности.

        Таким образом, итоговые формулы для обновления параллельных и перпендикулярных поверхности
        векторов, соответственно:
        \begin{eqnarray}
          \vect{t}_i\!' & = & \matx{R} \matx{S}^{ост} \vect{t}^{\;0}_i, \\
          \vect{n}'_i & = & \left(\left(\matx{R} \matx{S}^{ост}\right)^{-1}\right)^\transposed \vect{n}^0_i.
        \end{eqnarray}
\end{original}

        Transformation of normals is different. Let $\vect n$ be a normal, than the tangential plane
        for the point $\vect{x}_0$ is defined by the following equation
        \[
        \vect{n}^\transposed (\vect x - \vect{x}_0) = 0.
        \]
        Let $\matx M$ be the matrix that is used for transforming positions of points. Then taking
        into account that $\matx{M}^{-1} \matx{M} = \matx{E}$ the plane equation yields:
        \[
          \vect{n}^\transposed \matx{M}^{-1} \matx{M} (\vect x - \vect{x}_0) = 0,
        \]
        which is equivalent to
        \[
           \left( (\matx{M}^{-1})^\transposed \vect{n} \right)^\transposed (\matx{M} \vect x - \matx{M} \vect{x}_0) = 0.
        \]
        This implies that $(\matx{M}^{-1})^\transposed \vect{n}$ is normal to the tangential plane
        transformed with the matrix $\matx M$. So then, the vectors normal to the surface are
        transformed with the transposed inverse of the matrix used to transform positions.

        Finally, the formulas for updating parallel and normal to the surface vectors are, respectively:
        \begin{eqnarray}
          \vect{t}_i\!' & = & \matx{R} \matx{S}^{res} \vect{t}^{\;0}_i, \label{eq:tangent_vectors} \\
          \vect{n}'_i & = & \left(\left(\matx{R} \matx{S}^{res}\right)^{-1}\right)^\transposed \vect{n}^0_i. \label{eq:normal_vectors}
        \end{eqnarray}

\begin{original}
        \paragraph{Необходимость коррекции векторов.}
        Такие векторы, как нормаль или векторы тангенциального базиса, как правило, должны быть
        нормализованы. Однако описанные выше преобразования векторов не гарантируют сохранения
        нормы. Поэтому, если в~этом есть необходимость, после действия описанного выше преобразования
        они должны быть снова нормализованы в~использующем систему приложении.
\end{original}

        \paragraph{Need for correction of vectors.}
        Such vectors as normals or tangential basis vectors, as a rule, have to be normalized.
        However, the transformations described above do not guarantee the conservation of their
        norm. That is why after these transformations they should be normalized again in the host
        application, if it is necessary.

    \subsection{Parallel computing}\label{ssec:parallel}

\begin{original}
      В разделе~\ref{sec:task} было сказано, что одной из задач, поставленных в данной работе, является эффективное использование
      мощности многоядерных процессоров за счёт применения параллельных вычислений.
      Это актуально, поскольку многоядерные процессоры
      приобретают в~последнее время всё большее распространение \cite{steam-hardware}.
      % TODO можно сказать, что сейчас растёт частота, а не количество ядер
      Чтобы расчёты могли выполняться параллельно, необходимо разбить алгоритм на независимые
      блоки, называемые задачами, и реализовать менеджер задач, обеспечивающий их параллельное
      выполнение. Кроме того, часть вычислений по обработке отображаемой сетки может быть перенесена
      на графический процессор.
      % TODO Денис: Вот тут есть концептуальный косяк :) Ты фактически говоришь, что для
      % параллельных вычислений нужно применить метод А. Но ведь есть ещё целая куча других моделей
      % параллельных вычислений (не только задачи). Сети петри, там, можешь ещё про Axum почитать ;)
      % Тут надо либо аккуратно окучить тему, либо чётко описать, почему именно используются задачи.
\end{original}

      In the section~\ref{sec:task} it was mentioned that one of the objectives of this work is
      effective exploitation of multi-core processors' power by means of parallel computing.
      It is relevant since multi-core processors become prevalent nowadays~\cite{steam-hardware}.
      In~order to make parallel computation possible it is necessary to split the algorithm into the
      independent blocks called \emph{tasks} and to implement a task manager responsible for their
      parallel execution. Furthermore, some part of computations for updating visible mesh can be
      delegated to a graphical processor.

      \subsubsection{Splitting algorithm into tasks}\label{sssec:parallel_tasks}

\begin{original}
        Основной алгоритм содержит этап, состоящих из независимых однотипных блоков
        действий~--- это выполнение сопоставления формы для каждого кластера. Входными данными для
        сопоставления формы являются текущие позиции вершин, и они не изменяются в процессе
        его выполнения. Поэтому не важно, в каком порядке эта операция будет применена ко всем
        % TODO хорошо ли так выделять задачи, не будет ли оверхеда если их сильно много?
        кластерам, и её выполнение для отдельного кластера можно выделить в~качестве независимой задачи. Остальная
        часть алгоритма~--- это действия над всем набором вершин, каждое из которых использует
        результат предыдущего. Их нельзя выполнять параллельно, поэтому все они объединяются в~одну
        задачу, выполняемую после завершения всех задач первого этапа, далее называемую <<задачей
        обработки всего объекта>>. Поскольку матрицы, входящие
        в~формулу \eqref{eq:graphical_pos}, к началу работы над задачей обработки всего объекта уже вычислены,
        расчёт деформации отображаемой сетки может производиться параллельно выполнению этой задачи.
\end{original}

        The basic algorithm includes a stage consisted of independent and uniform blocks of
        actions. It is a stage of shape matching for every cluster. Current positions of the
        vertices, being the input data of this stage, are not changed during its execution. So that
        the order of applying this operation to each cluster is not important. That is why its
        application to a single cluster can be separated as an independent task. The remaining part
        of the algorithm includes actions performed over the whole set of vertices at once, each of
        which uses the result of the previous one. They cannot be executed in parallel, so they all
        are combined into a single task which is executed after all tasks of the first stage are
        completed. This big task is called \emph{the whole-body processing task} further. It is
        important here that the matrices included in the formula \eqref{eq:graphical_pos} are
        already computed by the start of this whole-body processing task. It means that updating the
        displayed mesh can be done simultaneously with the execution of this task.

      \subsubsection{Task manager}\label{sssec:task_manager}

\begin{original}
        За параллельное выполнение задач и соблюдение порядка, в котором они должны начинать
        исполнение, отвечает менеджер задач. При разработке компонента
        для приложения виртуальной реальности нужно учитывать, что в~этом приложении
        может быть собственный менеджер задач. В этом случае более эффективно
        будет использовать его возможности по распределению задач между потоками, чем делать это
        самостоятельно. Кроме того, исключая зависимость от конкретной библиотеки для управления
        потоками, можно улучшить переносимость системы. Таким образом, система должна лишь
        предоставлять интерфейс для получения и выполнения задач в правильном порядке,
        удовлетворяющий условию потоковой безопасности (англ. \eng{thread-safe}), то есть
        функционирующий корректно при одновременном доступе из нескольких потоков. Далее такой
        интерфейс называется <<потокобезопасной очередью задач>>. Под очередью здесь понимается именно строгий порядок выдачи
        задач на исполнение, завершение предыдущей задачи для начала выполнения следующей не требуется.
\end{original}

        A task manager is a unit responsible for parallel execution of tasks and controlling their
        order. It should be taken into account during its development that the host application may
        already have its own task manager. In this case the most effective approach is to use its
        abilities of distribution tasks between execution threads instead of doing it singly.
        Further, portability of the system is improved by eliminating the dependence on particular
        library for thread management. Thus the system should only provide a thread-safe interface
        for obtaining and executing the tasks in the appropriate order. Such interface is called
        a~\emph{thread-safe task queue}. By queue here meant is merely the strict order of starting
        tasks, but finishing a task before starting the next one is not required.

      \subsubsection{Using graphical processor}\label{sssec:using_gpu}

\begin{original}
        Графический процессор входит во все современные видеоадаптеры и предназначен, в
        первую очередь, для ускорения процесса получения изображения трёхмерной сцены. Современные
        графические процессоры обладают высокой вычислительной мощностью и позволяют выполнять
        расчёты, напрямую не связанные с~созданием изображения. При использовании графического
        ускорителя для таких расчётов вычислительная нагрузка распределяется между ним и центральным
        процессором, что даёт ускорение за счёт их параллельной работы. Применение графического
        процессора для расчётов в~данной системе не должно создать дополнительных системных
        требований у использующего её приложения, поскольку в~последнее время большинство компьютерных игр и
        приложений виртуальной реальности требуют его наличия для расчёта трёхмерной графики. В~случае если
        использование видеоадаптера всё-таки невозможно или является причиной проблем
        с~производительностью, расчёты могут быть выполнены целиком на центральном процессоре, для
        чего система предоставляет отдельный интерфейс.
\end{original}

        Graphical processors are included into all contemporary video adapters and are intended
        primarily for accelerating the process of generating images of 3D scenes. Modern graphical
        processors have high computational power and allow performing computations which are not
        related directly to producing images. When a graphical processor is used for such
        computations the computational load is distributed between it and the central processor,
        thus giving an acceleration due to their parallel operation. Applying a graphical processor
        for computations in this system should not create additional hardware requirements for the
        host application, since today most of computer games and virtual reality applications
        already require its presence for the sake of computing 3D graphics. In case if using video
        adapter is nevertheless impossible or causes performance problems the computation still can
        be performed entirely on the central processor. The system provides a separate interface for
        this case.

\begin{original}
        \paragraph{Возможности графического процессора.}
        Процесс создания изображения графическим процессором представляет собой конвейер,
        осуществляющий параллельную обработку данных на каждом этапе: отдельных вершин,
        геометрических примитивов и, в~итоге, пикселей отображаемого на экране двумерного
        изображения. За обработку на каждом этапе отвечает специальная программа~--- шейдер,
        применяемая к~каждому обрабатываемому объекту в~отдельности: вершине, примитиву или пикселю.
        Кроме данных текущего объекта шейдер имеет доступ к~данным, одинаковым для всех объектов
        данного этапа~--- константам шейдера.
\end{original}

        \paragraph{Possibilities of graphical processors.}
        The process of creating an image by a graphical processor is a pipeline performing parallel
        processing of data at each stage. The types of processed data are vertices, geometrical primitives
        and, finally, pixels of displayed 2D image. A special program called \emph{shader} is
        responsible for processing at each stage. It is applied independently to each object: a
        vertex, a primitive or a pixel. Besides the current object a shader has access to some data
        identical for all objects of this stage called \emph{shader constants}.

\begin{original}
        \paragraph{Выбор подходящей задачи.}
        В~связи с~перечисленными выше особенностями шейдеров, не всякая задача может быть выполнена
        на графическом процессоре. В~данной работе наиболее подходящей для этого является задача
        вычисления новых позиций вершин отображаемой сетки в~результате деформации. Во-первых, один
        из этапов графического конвейера отвечает именно за обработку вершин. Во-вторых, согласно
        формуле~\eqref{eq:graphical_pos}, для вычисления позиции каждой вершины требуется только её
        начальная позиция и параметры кластеров, одинаковые для всех вершин, то есть только те
        данные, которые доступны в~вершинном шейдере. Наконец, при вычислении используются только
        арифметические операции над векторами и умножение матрицы на вектор, которое может быть
        представлено как последовательные скалярные произведения. Все эти операции присутствуют
        в~наборе инструкций графического процессора.
\end{original}

        \paragraph{Choosing an appropriate task.}
        As a consequence of the listed features of shaders not all of the tasks can be executed on
        a graphical processor. In this work the most suitable task for it is computing new positions
        of the visible mesh vertices after deformations. First, one of the stages of the graphical
        processor pipeline is exactly for processing the vertices. Second, according to the
        formula~\eqref{eq:graphical_pos} only the initial position of vertex and the constant parameters of
        clusters are required for computing a new position of the vertex. That is, all required data
        are available in the vertex shader. Finally, only vector arithmetic operations and multiplying
        a matrix by a vector are used in computation. All these operation are present in the
        instruction set of graphical processors.

\begin{original}
        \paragraph{Реализация вычислений в вершинном шейдере.}
        Таким образом, вычисление $\vect{x}'_i$ по формуле~\eqref{eq:graphical_pos} и последующее
        усреднение (в случае нес\-коль\-ких кластеров) может быть выполнено в~вершинном шейдере, если
        необходимые параметры всех кластеров (исходный и текущий центр масс и матрица $\matx D =
        \matx{R} \matx{S}^{ост}$) будут переданы в~качестве констант шейдера. Поскольку каждая
        вершина может входить в~несколько кластеров, с~ней необходимо связать индексы кластеров, в
        которые она входит. Аналогичная задача возникает при реализации скелетной анимации с~помощью
        матриц (англ. \eng{Skinning}) \cite{gpu-gems-skinning}, поэтому здесь используется схожий подход.
        Число кластеров, в~которые входит вершина, может быть различным у разных вершин. Поскольку
        структура, задающая вершину, не может иметь переменный размер, то набор индексов задаётся
        в~виде массива фиксированного размера и числа элементов в наборе. Размер массива равен
        максимальному возможному числу кластеров для одной вершины, зависящему от способа разбиения
        на кластеры. Число кластеров и их индексы должны быть заданы для каждой вершины в~процессе
        инициализации объекта. При этом в~основном цикле уже не требуется
        производить запись в~буфер отображаемых вершин, необходимо лишь записывать новые значения
        параметров кластеров в соответствующие константы шейдера. Поэтому в~данном случае описатель
        вершины несёт другую функцию, нежели при вычислении на центральном процессоре: вместо
        расположения в~структуре всех точек и векторов, требующих обновления, он теперь должен
        хранить лишь расположение следующих величин: позиции (требуется для определения
        принадлежности кластерам), числа кластеров и их индексов (будут записаны единожды в
        конструкторе объекта).
\end{original}

        \paragraph{Implementation of computations in a vertex shader.}
        Thus the computation of $\vect{x}'_i$ according to the equation~\eqref{eq:graphical_pos} and
        subsequent averaging (in case of multiple clusters) can be performed in a vertex shader if
        required parameters of all clusters (the initial and the current center of mass and the
        matrix $\matx D = \matx{R} \matx{S}^{res}$) are passed to it as shader constants. Since
        every vertex may be included into several clusters, their indices should be associated with
        the vertex. An analogous task arises during implementation of skinning animation with
        matrices, so a similar approach is used here. The number of clusters including
        a vertex may vary between different vertices. Since the structure describing a vertex cannot
        have a variable size, a set of indices is represented as an array of fixed size and the
        number of elements in the array. The size of array is equal to maximum possible number of
        clusters for a single vertex which depends on the method of decomposing the object into
        clusters. These values are written only once during the initialization of the object. The
        need for writing into the buffer of visible vertices in the main loop is thus eliminated.
        Instead, only the new parameters of clusters should be copied into appropriate shader constants.

\begin{original}
        \paragraph{Используемые ресурсы.}
        Константы шейдера хранятся в~специальных регистрах графического процессора. Каждый такой регистр
        представляет вектор из четырёх компонент~--- чисел с плавающей точкой одинарной точности
        (float). В используемом методе требуется для каждого
        кластера передавать в шейдер две матрицы $3 \times 3$ (для преобразования точек и нормалей) и два
        вектора~--- начальный и текущий центр масс. Вектор текущего центра масс можно объединить с
        матрицей преобразования точек в матрицу $3 \times 4$. Каждая матрица занимает 3~регистра,
        поэтому всего на каждый кластер требуется 7~регистров. Несмотря на то, что система
        поддерживает произвольное число кластеров, количество доступных регистров для констант
        шейдера накладывает на него ограничение, которое должно быть учтено пользователем системы.
        Подробнее эта проблема рассмотрена в п.~\ref{sssec:limitations}.
\end{original}

        \paragraph{Utilized resources.}
        Shader constants are stored in the special registers of a graphical processor. Each register
        represents a four-component vector of floating-point numbers. In this method for each
        cluster it is necessary to pass into shader two $3 \times 3$ matrices (for transforming
        points and normals) and two vectors: the initial and the current center of mass. The current
        center of mass vector can be combined with a point transformation matrix into a single
        matrix $3 \times 4$. Each matrix occupies 3~registers, therefore a total of 7~registers is
        required for each cluster. Despite the system can handle any number of clusters, a fixed
        quantity of available constant registers imposes a limitation on this number, which should
        be taken into account by the developers of the host application.

  \section{Testing}

\begin{original}
      Корректность работы системы была протестирована на двух уровнях: на уровне отдельных функций и на
      уровне системы в~целом. Для тестирования отдельной функции применяется модульное тестирование (англ. \eng{unit testing}):
      пишется несколько тестов, проверяющих корректность её работы в~характерных случаях. Таким
      образом удобно тестировать все функции подсистемы математических расчётов и подсистемы
      журналирования и обработки ошибок, функции доступа к~полям классов, обработку некорректных
      аргументов, расчёт таких предсказуемых величин, как центр масс кластера или
      момент инерции объекта. Преимуществами модульного тестирования являются лёгкость локализации ошибки
      (за счёт того, что сразу известно, какая функция работает некорректно) и возможность
      убедиться, что система по-прежнему работоспособна после внесения изменений, в~том числе
      после рефакторинга или оптимизации. В~то же время, не менее важно тестировать правдоподобность
      моделируемых деформаций. Но сформулировать математический критерий правдоподобности сложно,
      поэтому модульные тесты плохо подходят для такого тестирования. Чтобы оно могло осуществляться
      человеком, разработано простое интерактивное приложение, позволяющее пользователю подвергать
      тестовый объект различным воздействиям и наблюдать изменения, происходящие при этом с
      трёхмерной моделью объекта.
\end{original}

      Correctness of the system operation was tested at two levels: the level of individual
      functions and the level of the whole system. Unit-testing was applied for testing
      functions: a few tests were written for each of them which ensure that it works
      correctly in some typical cases. This approach is convenient for testing mathematical
      functions, utility functions such as logging and error handling, field access methods; for
      checking handling of incorrect arguments and computing such predictable values as the center
      of mass or the moment of inertia. Advantages of unit-testing are the ease of
      localization of a mistake and the possibility to validate operational integrity of the system
      after major changes such as refactoring and optimization. At the same time it is important to
      test the plausibility of simulated deformation. But it is difficult to formulate a
      mathematical criteria of plausibility, so automated tests do not suit well for this task. Such testing
      should be performed by a human, so a simple interactive application was developed. It allows
      users to expose a test object to different impacts and to observe the consequent changes of 3D
      model of the object

  \section{Results}\label{sec:results}

\begin{original}
    Система моделирования деформаций была реализована в~виде статической
    библиотеки объектных модулей, написанной на языке C++. Было разработано тестовое приложение,
    использующее эту библиотеку, которое средствами API DirectX~9 отображает трёхмерную модель
    объекта и позволяет моделировать его деформации под действием ударов с разных сторон. Трёхмерная
    модель может быть загружена в приложение из файла либо сгенерирована по заданным параметрам при
    запуске.
\end{original}

    The system for modelling deformations was implemented as a statically-linked library written in
    C++. A test application using this library was developed. It displays the 3D model of an object
    by means of DirectX~9 API and performs simulation of its deformations under the action of
    strokes from different directions. A 3D model may be loaded into the application from a file or
    generated during the launch according to predefined parameters.

\begin{original}
    С использованием тестового приложения был проведён ряд экспериментов над тестовыми объектами.
    В ходе экспериментов измерена производительность системы, определены оптимальные параметры алгоритма,
    % TODO Денис: сначала даются ограничения, а потом делается система. А у тебя вышло, что ты её сделал, а потом сказал ограничения
    выявлены основные требования к~входным данным и прочие ограничения, а~также обнаружены некоторые
    особенности используемого метода моделирования. Эти результаты представлены в~последующих подразделах.
\end{original}

    \subsection{Test objects}\label{ssec:test_objects}

\begin{original}
      Для проверки правдоподобности деформаций и измерения производительности использовались два
      тестовых объекта: <<Цилиндр>> (с~простой геометрией) и <<Автомобиль>> (с~более сложной
      геометрией), они рассмотрены далее.
\end{original}

      Two test objects were used to check the realism of deformations and to measure the
      performance: ``Cylinder'' (with simple geometry) and ``Automobile'' (with more complex
      geometry).

      \subsubsection{Cylinder}\label{sssec:cylinder}

\begin{original}
        В качестве объекта с простой геометрией используется цилиндр, содержащий
        \num{2362} точки в физической модели, сгруппированные в 16 кластеров, и \num{20102} вершины (\num{40398}
        треугольников) в отображаемой сетке. Исходная форма объекта на рис.~\ref{fig:cylinder-initial}.
\end{original}

        As an object with simple geometry here used is a cylinder of \num{2362} points in the
        physical model grouped into 16 clusters and \num{20102} vertices (\num{40398} triangles) in
        the visible mesh. Its initial shape is shown in fig.~\ref{fig:cylinder-initial}.

        \begin{myfigure}{test object ``Cylinder''}{fig:cylinder}
          \subfigure[width=0.25\textwidth]{Initial state}       {cylinder-initial}    \hspace{1cm}
          \subfigure[width=0.25\textwidth]{Hit at the middle}   {cylinder-deformed-1} \\
          \subfigure[width=0.25\textwidth]{Hit at the edge}     {cylinder-deformed-2} \hspace{1cm}
          \subfigure[width=0.25\textwidth]{Combination of hits} {cylinder-deformed-3}
        \end{myfigure}

\begin{original}
        Были протестированы следующие случаи воздействия на объект:
        \begin{enumerate}
          \item Поперечный удар в середину объекта, см. рис.~\ref{fig:cylinder-deformed-1}.
          \item Продольный удар в край объекта, см. рис.~\ref{fig:cylinder-deformed-2}.
          \item Комбинация ударов, см. рис.~\ref{fig:cylinder-deformed-3}.
        \end{enumerate}
\end{original}

        The following cases of impacts were tested:
        \begin{enumerate}
          \item A lateral hit at the middle of the object, see fig~\ref{fig:cylinder-deformed-1}.
          \item A lateral hit at the edge of the object, see fig.~\ref{fig:cylinder-deformed-2}.
          \item A combination of impacts, see fig.~\ref{fig:cylinder-deformed-3}.
        \end{enumerate}

\begin{original}
        Также было проведено исследование зависимости времени расчётов от числа вершин в физической
        модели и отображаемой сетке. Для каждого числа вершин производилось 5 запусков тестового
        % TODO померить действительно в таких условиях
        приложения, каждый из которых длился 10 секунд. На объект оказывались одинаковые воздействия. Во время
        исполнения на каждом кадре измерялось время, требуемое для физического моделирования и для
        вычисления позиций вершин отображаемой сетки. По получаемой выборке рассчитывалось
        % TODO больше думать про обработку данных
        среднее значение. Многократные запуски необходимы, чтобы исключить
        факторы, внешние по отношению к~приложению, например, загрузку процессора другими приложениями
        и операционной системой. Измерения производились на компьютере со следующими
        характеристиками: четырёхъядерный процессор Intel Core 2 Quad Q6600, тактовая частота
        \num{2.4} ГГц, видеоадаптер NVIDIA GeForce 8800 GTX.
        Результаты измерений представлены в виде графика на рис.~\ref{fig:time-plot-en}.
\end{original}

        Also the dependence of the computation time on the number of vertices in physical and
        displayed models was investigated. For each number of vertices the test application was
        launched 5 times for 10 seconds each time. The object was subjected to the similar actions.
        Results were averaged between launches. It is necessary to eliminate the influence of
        external factors such as loading the processor by other applications and the operating
        system. The following computer was used for testing: quad-core Inter Core 2 Quad Q6600
        processor with clock speed \num{2.4} GHz, graphical processor NVIDIA GeForce 8800 GTX.
        Results are presented as a plot, see fig.~\ref{fig:time-plot-en}.

        \includefigure[width=1\linewidth]{dependence of simulation time on the number of physical
        vertices and of mesh updating time (on central and graphical processors) on the graphical
        vertices number.}{time-plot-en}

\begin{original}
        \paragraph{Выводы.} Зависимость от числа вершин обоих типов близка к линейной.
        Горизонтальный участок зависимости для отображаемых вершин связан с тем, что, даже когда
        вычисления на графическом процессоре занимают очень мало времени, имеются
        постоянные накладные расходы времени. Например, на передачу данных между графическим и центральным
        процессором и на растеризацию изображения. Из графика следует, что затраты времени на
        одну вершину физической модели значительно выше затрат на одну отображаемую вершину. Таким
        образом, использование физической модели с~меньшим числом вершин и последующий перенос
        её деформаций на отображаемую сетку с~б\'{о}льшим числом вершин оправданы.
        Более того, выполнение этого переноса на графическом процессоре позволяет получить
        существенный выигрыш по времени по сравнению с использованием центрального процессора для
        этой цели.
\end{original}

        \paragraph{Conclusions.} The dependence on the vertices number is close to linear.
        Horizontal region of the plot for displayed vertices is due to constant overhead for data
        transfer and rasterization exceeding computation time on low vertices numbers. The plots
        show that the time cost of simulation per vertex is more than the cost of updating the mesh.
        It proves the assumptions that using less detailed model for modelling accelerates the
        process. Moreover, a significant gain can be achieved by using a graphical processor.

      \subsubsection{Automobile}\label{sssec:car}

\begin{original}
        В качестве объекта со сложной геометрией используется автомобиль, содержащий
        \num{9413} точек в физической модели, сгруппированные в~24 кластера, и \num{28241} вершин (\num{34534}
        треугольника) в отображаемой сетке. Исходная форма объекта показана на рис.~\ref{fig:car-initial}.
\end{original}

        As an object with complex geometry here used is a model of automobile consisting of \num{9413}
        points in the physical model grouped into \num{24} clusters and \num{28241} vertices
        (\num{34534} triangles) in the visible mesh. The initial shape of the object is shown in
        fig.~\ref{fig:car-initial}.

        \begin{myfigure}{test object ``Automobile''}{fig:car}
          \subfigure[width=0.3\textwidth]{Initial state}       {car-initial}    \hspace{1cm}
          \subfigure[width=0.3\textwidth]{Hit at the middle}   {car-deformed-1} \\
          \subfigure[width=0.3\textwidth]{Hit at the edge}     {car-deformed-2} \hspace{1cm}
          \subfigure[width=0.3\textwidth]{Combination of hits} {car-deformed-3}
        \end{myfigure}

\begin{original}
        Были протестированы следующие случаи воздействия на объект:
        \begin{enumerate}
          \item Поперечный удар в середину объекта, см. рис.~\ref{fig:car-deformed-1}.
          \item Продольный удар в край объекта, см. рис.~\ref{fig:car-deformed-2}.
          \item Комбинация ударов, см. рис.~\ref{fig:car-deformed-3}.
        \end{enumerate}
\end{original}

        The following cases of impacts were tested:
        \begin{enumerate}
          \item A lateral hit at the middle of the object, see fig~\ref{fig:car-deformed-1}.
          \item A lateral hit at the edge of the object, see fig.~\ref{fig:car-deformed-2}.
          \item A combination of impacts, see fig.~\ref{fig:car-deformed-3}.
        \end{enumerate}

\begin{original}
        Чтобы проверить масштабируемость многопоточного алгоритма, было проведено сравнение быстродействия
        версий тестового приложения с разным числом рабочих потоков, от 1 до 4, на четырёхъядерном
        процессоре. Как было показано в п.~\ref{sssec:parallel_tasks}, вычисления разбиваются на два
        этапа, и только задачи первого этапа независимы и выполняются параллельно, а остальные
        вычисления производятся после завершения первого этапа. Поэтому измерялось отдельно время,
        требуемое для каждого этапа. Ожидалось, что для первого этапа оно будет убывать обратно
        пропорционально числу потоков, а для второго этапа~--- оставаться неизменным.
        Измерения производились на компьютере со следующими характеристиками: четырёхъядерный
        процессор Intel Core i5-750, тактовая частота \num{2.66} ГГц, видеоадаптер NVIDIA GeForce GTS 250.
        Полученные результаты представлены на рис.~\ref{fig:thread-plots}: диаграмма на
        рис.~\ref{fig:time-plot-threads-en} показывает зависимость времени расчётов от числа потоков, а
        график на рис.~\ref{fig:speedup-plot-en}~--- выраженное в процентах отношение затрат времени
        однопоточной версией к затратам при нескольких параллельных потоках, показывающее, во сколько раз
        многопоточная версия системы быстрее однопоточной.
        % TODO время расчётов на GPU тоже бы
\end{original}

        In order to check the scalability of multi-threaded algorithm the performance of test
        application versions with different count of working threads (from 1 to 4) was compared
        using a quad-core processor. As it was explained in sec.~\ref{sssec:parallel_tasks}, the
        computation is divided into two stages, and only the tasks of the first stage are
        independent and are executed in parallel, while the rest of computation is done only after
        the end of the first stage. That is why the time of each stage was measured. It was expected
        that for the first stage it would decrease in inverse proportion with the number of threads
        and for the second stage it would remain constant. The experiments were conducted using the
        following computer: a quad-core Intel processor Core i5-750 with clock speed \num{2.66} GHz,
        a graphical processor NVIDIA GeForce GTS 250. The results are presented in
        fig.~\ref{fig:thread-plots}: diagram in fig.\ref{fig:time-plot-threads-en} shows the dependence
        of the time of computation on the number of threads, and
        fig.~\ref{fig:speedup-plot-en} contains the plot the ratio of execution time between single-threaded and
        multi-threaded versions showing how much times faster the multi-threaded version is.

        \begin{myfigure}{dependence of computational speed on the number of threads executed on different processor cores}{fig:thread-plots}
          \subfigure[width=0.45\textwidth]{Computation time}{time-plot-threads-en}
          \subfigure[width=0.45\textwidth]{Speeds ratio for multi-threaded and single-threaded
          versions}{speedup-plot-en}
        \end{myfigure}

\begin{original}
        \paragraph{Выводы.}
        Наблюдается рост скорости той части вычислений, которая выполняется параллельно, при увеличении числа потоков.
        Характер этого роста близок к линейному, но при одновременной работе всех четырёх
        ядер процессора достигается ускорение только в~\num{2.2} раза. Такое ускорение оправдывает
        применение многопоточности в данной системе при использовании её на многоядерных процессорах, но не
        является максимальным достижимым. Этот факт указывает на то, что имеется возможность для
        дальнейшего улучшения реализации параллельных вычислений.
\end{original}

        \paragraph{Conclusions.}
        Observed is the growth of speed of paralleled part of computations with the increasing
        of threads count. The nature of this growth is close to linear, but when all four cores work
        simultaneously the achieved acceleration is only \num{2.2} times. Such acceleration
        justifies the application of multi-threading in this system if it is used on multi-core
        processors, but it is not the theoretical maximum. It points to the fact that the
        implementation of parallel computing in the system can be further improved.

\begin{original}
        В~целом, было показано, что поставленная цель достигнута: система моделирует визуально
        правдоподобные деформации объектов, имеющих типичную для приложений виртуальной реальности
        степень детализации, и на расчёты требуется менее 3 мс на кадр. Тем не менее, для этого
        должны быть соблюдены определённые условия, подробно описанные далее.
\end{original}

        As a whole, the tests showed that the goal of this work is achieved: the system does
        simulate visually plausible deformations of the objects having the level of detail typical
        for virtual reality applications and takes less than 3 ms for computing a frame.

\begin{original}

  \section{Further work}

\begin{original}
    В дальнейшем планируется работа по ослаблению требований, перечисленных
    в подразделе~\ref{ssec:requirements}. В~частности, описанные там же действия для коррекции
    представления объекта и разбиения на кластеры могут выполняться автоматически.
\end{original}

    In future the work is planned to reduce the limitation of algorithms, including automatic
    correction of object representation and decomposition into clusters.

\begin{original}
    Алгоритм имеет довольно много входных параметров, включая разбиение на кластеры и
    различные численные параметры, описанные в подразделе~\ref{ssec:optimal_parameters}. Задание их вручную в коде для каждого
    объекта является неудобным. Планируется разработка программного модуля для редактора
    трёхмерной графики Autodesk 3ds Max, в котором дизайнер сможет удобным способом задавать эти параметры. При этом
    будет разработан собственный формата файла для хранения этих параметров, разбор которого будет
    осуществляться внутри данной системы. Это позволит применять систему в~реальных приложениях
    виртуальной реальности, которые обычно содержат множество разнообразных деформируемых объектов.
\end{original}

    The algorithm has many input parameters including decomposition into clusters and different
    numeric parameters. Defining them by hand in the code for each object is inconvenient. It is
    planned to develop a plug-in module for 3D graphics editor Autodesk 3ds Max for defining this
    parameters using intuitive graphical interface. A special file format for storing this
    parameters will be developed. This will allow using this system in real virtual reality
    applications which usually include lots of different deformable objects.

  \section{Conclusion}\label{sec:conclusion}

\begin{original}
    % TODO Можно цифры ещё сюда
    В данной работе ставилась цель разработать систему моделирования деформаций неупругих тел
    в~реальном времени, ориентированную на применение в~приложениях виртуальной реальности. Эта цель
    была достигнута, и были удовлетворены поставленные в разделе~\ref{sec:task} требования, включая
    высокое быстродействие и удобный для интеграции интерфейс, а~также применение параллельных
    вычислений и отказ от использования предварительно рассчитанных деформаций. Более того,
    использование графического процессора позволило значительно улучшить быстродействие.
\end{original}

    For this work the goal was set to develop a system for modeling plastic deformations of bodies
    in real-time oriented to using in virtual reality applications. This goal was achieved and the
    requirements listed in sec.~\ref{sec:task} were met, including high performance and the
    interface ready for easy integration, as well as using parallel computing and rejection of using
    precomputed deformations. Moreover, the application of a graphical processor significantly
    improved the performance.

\begin{original}
    Предусмотрено тестирование системы с~помощью модульных тестов. Также было разработано простое интерактивное
    приложение, использующее возможности системы, чтобы моделировать деформаций предварительно
    заданного объекта. С помощью этого приложения была протестирована правдоподобность деформаций и
    исследованы быстродействие и зависимость характера деформаций от параметров алгоритма.
    При правильном подборе этих параметров система моделирует достаточно реалистичные изображения
    для применения её в приложениях виртуальной реальности.
    Также были исследованы возможности дальнейшего развития и улучшения системы. В частности, планируется разработка
    дополнительных инструментов, упрощающих использование системы разработчиками приложений
    виртуальной реальности.
\end{original}

    The system was tested using unit-tests. Also developed was a simple interactive application using
    the abilities of the system for simulating deformations of a predefined object. It was used to
    test plausibility of simulation and to investigate the performance of the system. Given properly
    adjusted parameters modelled deformations are plausible enough for virtual reality applications.
    Possibilities of further development and improvement of the system were analysed as well. For
    example, the development of additional instruments simplifying the use of this system by virtual
    reality applications developers is planned.

  \begin{flushleft}
    \bibliography{../../biblio/my}
  \end{flushleft}
\end{document}

