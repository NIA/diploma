\documentclass[a4paper, 14pt, titlepage]{extarticle}
  \usepackage{cmap}
  \usepackage{mathtext} % для кириллицы в формулах
  \usepackage[T2A]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage[english,russian]{babel}
  \usepackage{indentfirst}
  \usepackage{cite}
  \usepackage{amsmath} % для \eqref
  \usepackage{color} % пока только для TODO
  \frenchspacing

  \DeclareSymbolFont{T2Aletters}{T2A}{cmr}{m}{it} % кириллица в формулах курсивом

  \addto\captionsrussian{
    \renewcommand\contentsname{Содержание}
  }

  \newcommand{\underscore}[1]{\hbox to#1{\hrulefill}}
  \newcommand{\todo}[1]{\textbf{\textcolor{red}{TODO: #1}}}

  \newcommand{\vect}[1]{\vec{#1}} % единое выделение векторов (стрелкой)
  \newcommand{\matx}[1]{\mathbf{#1}} % единое выделение матриц (полужирным)

  % поля и размер текста
  \textwidth=17cm
  \oddsidemargin=0pt
  \topmargin=0pt
  \headheight=0pt
  \headsep=0pt
  \textheight=24cm
  \linespread{1.3}

  \renewcommand{\theenumii}{(\asbuk{enumii})}
  \renewcommand{\labelenumii}{\asbuk{enumii})}

  \bibliographystyle{gost780u}

  \author{И.\,А.\,Новиков, кафедра АФТИ ФФ НГУ, гр.\,7305}
  \title{Система моделирования деформаций неупругих тел в реальном времени}

\begin{document}

%----------------------- титульный лист ------------------------

  \thispagestyle{empty} 
  \begin {center} 
  МИНИСТЕРСТВО ОБРАЗОВАНИЯ И НАУКИ РОССИЙСКОЙ ФЕДЕРАЦИИ 

  \vspace{0.3cm} 

  Новосибирский государственный университет 

  \vspace{0.3cm} 

  Физический факультет 

  Кафедра автоматизации физико-технических исследований

  \vspace {5cm} 

  Февральский отчёт 

  \vspace {1cm} 

  Новиков Иван Александрович

  \vspace {0.5cm} 

  \textbf{СИСТЕМА МОДЕЛИРОВАНИЯ ДЕФОРМАЦИЙ НЕУПРУГИХ ТЕЛ В РЕАЛЬНОМ ВРЕМЕНИ} 

  \vspace {2cm} 

  \begin{flushright} 

    Научный руководитель 

    Д.\,А.\,Гладкий

  \end{flushright}

  \vspace {5cm} 

  Новосибирск, 2011~г.
  \end {center} 

%------------------------- содержание -------------------------

  \tableofcontents
  \newpage

%-------------------------- введение --------------------------
  \section{Введение}

    Приложения виртуальной реальности становятся чрезвычайно рас\-прос\-тра\-нён\-ны\-ми в~наши~дни.  Два
    основных их типа~--- это компьютерные игры и~обучающие симуляторы (тренажёры). Несмотря на
    различные применения, эти два типа приложений имеют много общего, поскольку в~обоих случаях
    требуется создать иллюзию присутствия у~пользователя. Для~этого необходимо как генерировать
    фотореалистичные изображения, так и правдоподобно моделировать физику взаимодействия объектов
    виртуального мира: их движение, столкновения, деформации и~разрушение.

    Моделирование деформаций объектов является актуальной задачей, поскольку помимо приложений
    виртуальной реальности оно находит применение в~системах автоматизированного проектирования, а~также используется
    при~создании спецэффектов к~фильмам.  Как правило, в зависимости от конкретного применения
    используются различные алгоритмы, поскольку ставятся разные задачи и в каждом случае имеют место
    специфические ограничения. А~именно, в~системах автоматизированного проектирования требуется
    максимальная точность расчётов, в~то~время как в~фильмах и приложениях виртуальной реальности
    требуется лишь визуальная правдоподобность. При~этом, если расчёты для САПР и~спецэффектов могут
    выполняться длительное время, то в~интерактивных приложениях расчёт одного шага вычислений должен
    происходить не~дольше, чем за~промежуток между кадрами, чтобы обеспечивать плавную анимацию
    и чтобы отсутствовала задержка между воздействием на объект и его деформацией.

    Жёсткое требование быстродействия в приложениях реального времени не~только вынуждает
    использовать упрощённые физические модели деформации тела, менее точные, чем используемые
    в~инженерных расчётах, но и накладывают существенные ограничения на способ представления
    моделируемого объекта. Чаще всего он задаётся дискретным образом: в~виде сетки, решётки или
    несвязанного набора точек, причём время расчётов напрямую (как~правило, линейно
    \cite{mueller-meshless}) зависит от количества точек в таком представлении. Для отображения
    объектов обычно используют высоко детализированные сетки, содержащие вплоть до нескольких
    сотен тысяч и даже миллионов точек. Это значительно превышает максимальное допустимое число точек для~большинства
    алгоритмов \cite{mueller-stable, mueller-meshless, chang-crash} при расчётах в~реальном времени на
    современных настольных компьютерах и компьютерах, используемых в тренажёрах. Из-за этого
    невозможно использовать одно и~то~же представление объекта и для моделирования, и для
    отображения.

  \section{Описание предметной области}\label{domain}

    Существуют различные подходы к~моделированию деформаций в~реальном времени. В простейшем случае
    ограничения на~быстродействие алгоритма обходятся за счёт использования предварительно рассчитанных
    деформированных состояний для~некоторого конечного набора возможных ударов по~объекту, одно из которых
    (или~интерполяция между несколькими ближайшими) выбирается в~зависимости от~того, к~какому
    из~этих ударов ближе всего произошедший. В~этом случае допускается использование достаточно сложных
    для~вычисления алгоритмов, таких~как система масс и~пружин (англ. {\English mass-spring system})
    с~большим разрешением или~метод конечных элементов (англ. {\English finite elements method, FEM}).
    Однако, при ударе, отличающемся от~заранее рассчитанного, или в~случае сложной комбинации ударов
    моделируемые деформации будут выглядеть не реалистично \cite[с.~1064]{chang-crash}. Кроме того, значительное время, требуемое
    для предварительных расчётов после каждого изменения объекта, прежде чем он может быть загружен
    в приложение для тестирования, создаёт неудобства при разработке приложения. Поэтому наибольший
    интерес представляют решения, в которых моделирование деформаций происходит во время исполнения.

    Одной из~простейших моделей деформируемого тела является упоминавшаяся выше система масс
    и~пружин, в~которой тело представляется в~виде пространственной (как~правило, регулярной и
    кубической) решётки из~материальных точек, связанных между~собой пружинами, при~изменении длины
    прикладывающими к~своим концам силу согласно закону Гука. Будучи очень простой в~реализации,
    такая модель, тем не менее, имеет определённые недостатки. Она моделирует поведение объекта не
    очень точно, причём оно сильно зависит от формы решётки и расположения пружин в ней \cite[с.~8]{mueller-physmodels}.
    Другим недостатком является то, что возбуждение, приложенное локально, распространяется по
    объекту постепенно, перемещаясь на один шаг решётки за шаг алгоритма \cite[с.~232]{parent-animation}.
    Кроме~того, требуется выполнять дополнительную работу по конвертации представления объекта,
    используемого для его отображения (чаще всего это сетка из треугольников), в~регулярную решётку
    и~подбору значений коэффициента упругости пружин так, чтобы добиться требуемых свойств
    моделируемого материала.

    Принципиально другой подход реализуется в моделях, использующих метод конечных элементов, широко
    используемый в~инженерных расчётах. При таком подходе
    непрерывные характеристики деформируемого тела вычисляются путём интерполяции их~значений
    на~элементах конечного размера. Разумеется, использовать в чистом виде этот метод
    в приложениях реального времени невозможно, поскольку инженерные расчёты производятся в
    течение нескольких часов и даже суток. Однако, существуют модели, предлагающие различные упрощения этих
    методов, которые допускают вычисление в реальном времени, как, например в \cite{mueller-stable}.
    Деформации при этом моделируются намного точнее, чем в случае системы масс и пружин, но даже
    упрощённый алгоритм требует больше времени для вычислений. \todo{циферки.}

    Отдельно стоят так~называемые геометрические алгоритмы, в~которых напрямую не~моделируются
    физические законы. Как~правило, объект представляется в~виде системы частиц, движение каждой из
    которых сначала интегрируется независимо от~остальных, а~следующим шагом на объект в~целом
    накладываются различные физически мотивированные ограничения (сохранение формы, объёма, импульса
    и~т.п.), обеспечивающие в итоге правдоподобные деформации. Такие методы обладают хорошим
    быстродействием и могут вычисляться параллельно, при этом обладая большей устойчивостью и
    простотой в конфигурации, чем системы масс и пружин. Пример такого метода описывается в \cite{mueller-meshless}.

  \section{Постановка задачи}

    Целью работы является разработка системы моделирования деформаций объектов для применения в
    приложениях виртуальной реальности: в компьютерных играх и обучающих тренажёрах.
    К~системе предъявляются следующие требования.

    Необходимо использовать сетки из треугольников в качестве внутреннего представления, либо
    предоставить возможность конвертации, поскольку в приложениях виртуальной реальности отображаемые объекты
    чаще всего представляются именно в таком формате.

    Система должна иметь достаточное быстродействие, чтобы обеспечивать моделирование в~реальном
    времени. Чтобы это было возможно даже для~объектов, заданных сеткой с~большим числом вершин,
    должна иметься возможность использовать при~моделировании менее детализированное представление
    объекта, а~отображаемую сетку более высокого разрешения обновлять так, чтобы она повторяла
    рассчитанные деформации. При~этом важно предусмотреть некоторое сглаживание смещений точек
    отображаемого объекта, иначе в~их~движении можно будет проследить форму низко детализированного
    представления.

    Кроме~того, предварительно рассчитанные деформированные состояния не~должны использоваться,
    поскольку, как было объяснено в разделе~\ref{domain}, такой подход негативно сказывается на реалистичности
    моделирования и создаёт неудобства при разработке приложения.

    Наконец, интерфейс, предоставляемый системой, не~должен создавать трудностей при~интеграции
    системы в~приложения виртуальной реальности. Основные критерии, которым необходимо следовать,
    описаны в~\cite{gems-middleware} и~включают, в~частности, конфигурируемые обработку ошибок,
    логирование и~выделение памяти, а также отказ от~прямого доступа к~файловой системе в~пользу
    работы с~буферами в~оперативной памяти.

    Для достижения цели необходимо решить следующие задачи.
    \begin{enumerate}
      \item Разработать и~реализовать алгоритм моделирования в реальном времени деформаций
        не\-у\-пру\-гих тел, содержащих недеформируемые части;
      \item Предоставить интерфейс для~двустороннего взаимодействия с~приложением, в~которое будет
        встроена система, включающий:
        \begin{enumerate}
          \item конвертацию представления объекта, используемого в приложении, во внутреннее представление;
          \item получение извне информации о~столкновениях объекта и~приложенных к~нему силах;
          \item сообщение наружу о сильных локальных деформациях;
          \item обновление отображаемой сетки.
        \end{enumerate}
      \item Предусмотреть в~алгоритме возможность использования параллельных вычислений.
    \end{enumerate}

  \section{Предлагаемое решение}
    \subsection{Архитектура системы}

      Система реализуется в~виде модуля, который может быть встроен в~приложение виртуальной
      реальности: статической либо динамической библиотеки, написанной на языке C++. Выбор языка
      обоснован компромиссом между быстродействием и удобством разработки и интеграции, которые
      обеспечивает использование объектно-ориентированной парадигмы. В~системе выделяются следующие подсистемы.
      \begin{enumerate}
        \item Ядро системы, обеспечивающее собственно моделирование.
        \item Подсистема математических расчётов.
        \item Подсистема журналирования и~обработки ошибок.
      \end{enumerate}

      \subsubsection{Ядро системы}\label{sssec:core}
        
        Ядро системы реализует класс <<деформируемый физический объект>>. Он инициализируется
        начальной конфигурацией объекта и~предоставляет интерфейс для совершения с~ним следующих действий.
        \begin{enumerate}
          \item Задание приложенных сил и~произошедших столкновений.
          \item Определение реакции на~определённые события, происходящие при~деформации объекта.
          \item Моделирование процесса деформаций для~заданного промежутка времени.
          \item Обновление формы отображаемой сетки.
        \end{enumerate}

        Таким образом, для~обеспечения перечисленной функциональности система также реализует следующие классы.
        \begin{enumerate}
          \item Сила, приложенная к~объекту.
          \item Реакция на событие.
          \item Область в~трёхмерном пространстве.
          \item Описатель формата отображаемой сетки.
        \end{enumerate}

      \subsubsection{Подсистема математических расчётов}

        Подсистема математических расчётов реализует необходимые для~расчёта деформаций математические объекты
        и~функции.

      \subsubsection{Подсистема журналирования и~обработки ошибок}

        Данная подсистема обеспечивает обработку ошибок и~предупреждений, возникающих в~процессе
        работы системы, а~также запись в журнал. В приложении, использующем систему, может
        реализоваться своя политика обработки ошибок и журналирования. Для удобства интеграции
        стандартные действия, выполняемые в ответ на каждое из этих событий, можно переопределить
        в~соответствии с политикой приложения.

    \subsection{Основной алгоритм}\label{ssec:basic_algorithm}

      \todo{обосновать выбор.}\\
      В основу алгоритма моделирования взят геометрический алгоритм, предложенный в~\cite{mueller-meshless},
      вкратце описанный далее. 
      
      \subsubsection{Исходный алгоритм}

        \paragraph{Входные данные и результат.} Объект представляется в~виде набора точек,
        сгруппированных в~перекрывающиеся множества, называемые кластерами
        (информация о~связях между вершинами, то~есть об~образуемых ими полигонах, не требуется).
        На~вход алгоритма поступает заданный таким образом объект, а так же информация о~приложенных
        силах. Задаётся величина шага по времени. Результатом выполнения одной итерации алгоритма
        являются позиции точек, задающих объект, в следующий момент времени.
        
        \paragraph{Общая схема алгоритма.} Скорости и позиции этих точек интегрируются независимо
        друг от друга, для чего используется явная схеме Эйлера. Затем над каждым кластером
        производится операция сопоставления формы: вычисляется смещение центра масс кластера
        $\Delta \vect{x}_{ц.м.}$ и оптимальное линейное преобразование $\matx A$, действие которого
        переводит исходную форму кластера в~наиболее близкую к~текущей форме. В качестве критерия
        оптимальности используется сумма квадратов отклонений текущий позиций точек от начальных. Позиции
        вершин в кластере, подвергнутые оптимальному линейному преобразованию и смещению центра масс
        $\vect{g}_i = \matx{A} (\vect{x}^0_i - \vect{x}^0_{ц.м.}) + \Delta \vect{x}_{ц.м.}$,
        называются целевыми позициями. Здесь $\vect{x}^0_i$~--- исходная позиция вершины, а
        $\vect{x}^0_{ц.м.}$~--- исходный центр масс кластера. Для каждой вершины, исходя из величины
        отклонения текущей позиции от~целевой, рассчитывается поправка к~скорости, корректирующая
        это отклонение. Если вершина входит одновременно в~несколько кластеров, то~есть находится
        в~зоне их перекрытия, корректирующие поправки от~каждого из~кластеров усредняются, что
        обеспечивает целостность объекта: за~счёт этого кластеры, обрабатываемые независимо,
        не~отделяются друг от~друга.
        
        \paragraph{Остаточная деформация.} Для моделирования неупругости остаточная деформация
        каждого кластера сохраняется в~форме линейного преобразования $\matx{S}^{ост}$, то~есть
        матрицы $3 \times 3$. Изначально она единичная, а~изменение происходит, лишь когда мера
        текущей деформации превышает заданную пороговую величину. В~качестве такой меры может быть
        использована $ ||\matx S - \matx E||_2 $, где $\matx S$~--- симметричная компонента $\matx
        A$, $\matx E$~--- единичная матрица. Симметричная матрица $\matx S$ получается при полярном
        разложении матрицы $\matx A$:
        \begin{equation}\label{eq:polar_decomposition}
          \matx A = \matx R \matx S,
        \end{equation}
        где $\matx R$~--- ортогональная матрица. Остаточная деформация учитывается затем при
        сопоставлении формы и расчёте целевых позиций. А именно, исходные позиции перед сравнением
        с текущими при сопоставлении формы, преобразуются матрицей $\matx{S}^{ост}$. Таким
        образом, сопоставление происходит не с~исходной, а с деформированной формой. Формула для
        расчёта целевых позиций принимает следующий вид:
        \begin{equation}\label{eq:goal_pos}
          \vect{g}_i = \matx{A} \matx{S}^{ост} (\vect{x}^0_i - \vect{x}^0_{ц.м.}) + \Delta \vect{x}_{ц.м.}.
        \end{equation}
      
      \subsubsection{Предлагаемые изменения в алгоритме}\label{sssec:proposed_changes}

        В~исходный алгоритм вносятся некоторые изменения, адаптирующие его к~условиям данной
        задачи. В~частности, моделирование неупругих тел требует демпфирования возникающих колебаний.
        Нужно, чтобы затухали только колебания, а глобальное движение тела сохраняло свои характеристики.
        Для этого используется способ, описанный в~\cite[с.~5]{mueller-position-dynamics}. Сначала выделяется
        движение тела как~целого~--- вычисляются скорость центра масс $\vect{v}_{ц.м.}$ и угловая
        скорость $\vect{\omega}$, с~учётом предварительно рассчитанных характеристик тела: центра масс
        $\vect{x}_{ц.м.}$ и тензора инерции $\matx I$. Затем для каждой вершины вычисляется скорость,
        которую она имела~бы, если~бы тело было абсолютно твёрдым:
        \begin{equation}\label{eq:rigid_velocity}
          \vect{u}_i = v_{ц.м.} + \omega \times (\vect{x}_i - \vect{x}_{ц.м.}).
        \end{equation}
        Демпфированию подвергается только индивидуальное отклонение скорости вершины
        $\Delta \vect{v}_i = \vect{v}_i - \vect{u}_i$:
        \begin{equation}\label{eq:damping}
          \vect{v}_i = \vect{v}_i - k \Delta \vect{v}_i,
        \end{equation}
        где $k \in [0, 1]$. За счёт этого $\vect{v}_{ц.м.}$ и $\vect{\omega}$ сохраняются.

        Кроме того, система отвечает только за~моделирование деформаций, а глобальное движение и
        определение столкновений рассчитываются отдельно приложением, в~которое встроена система.
        Поэтому расчёт деформаций необходимо производить в~локальных координатах~--- в~системе отсчёта
        центра масс объекта. При~этом важно учесть, что вследствие удара или воздействия внешних сил
        у~тела может появиться как ненулевая скорость центра масс, так и ненулевая угловая скорость.
        Таким образом, система отсчёта, в~которой производится расчёт, перестанет быть системой центра
        масс. Поэтому после интегрирования скоростей и до интегрирования позиций вершин производится
        коррекция. Приобретённые на данном шаге $\vect{v}_{ц.м.}$ и $\vect{\omega}$ уже получены
        в~ходе расчёта демпфирования. Чтобы локальная система отсчёта снова стала системой центра масс,
        необходимо скомпенсировать их, вычитая из скорости каждой вершины $\vect{u}_i$ из \eqref{eq:rigid_velocity}.
        После этого приложение, в которое встроена система, должно получить из неё значения
        $\vect{v}_{ц.м.}$ и $\vect{\omega}$ и скорректировать глобальное движение объекта, прибавив их
        к его линейной и угловой скоростям соответственно.

    \subsection{Реализация дополнительных функций}

      Как уже говорилось в п.~\ref{sssec:core}, кроме собственно моделирования деформаций, ядро
      системы предоставляет дополнительную функциональность. Предлагаемые способы реализации этой
      функциональности описана далее.

      \subsubsection{Недеформируемые части объекта}

        Система позволяет задать множество вершин, сохраняющее свою форму~--- недеформируемую раму.
        Чтобы обеспечить это, используется та же техника, что и в алгоритме демпфирования,
        описанном в п.~\ref{sssec:proposed_changes}, только коэффициент $k$ в~\eqref{eq:damping}
        берётся равным единице, то есть индивидуальные отклонения скоростей $\Delta \vect{v}_i$
        подавляются полностью. Это действие необходимо также производить на каждом шаге, после
        интегрирования скоростей, но до демпфирования, иначе из-за порождённых колебаний система
        может стать нестабильной.

      \subsubsection{Обнаружение произошедших событий}

        Система может обнаружить следующие виды событий.
        \begin{enumerate}
          \item Удар в~заданною область, превышающий по~силе заданный порог;
          \item Отклонение некоторой точки объекта от~начальной формы больше заданного предела;
          \item Вход некоторой точки в~заданную область (или выход из~неё).
        \end{enumerate}
        Способ обнаружения каждого из событий описан далее.

        \paragraph{Удар в заданную область.}
        Простейшее событие~--- это удар в некоторую область, заданную массивом индексов
        входящих в~неё вершин. Для его определения нужно лишь проверить, входит ли хоть одна из этих
        вершин в~зону действия удара и превышает~ли изменение её скорости пороговую величину.

        \paragraph{Отклонение от начальной формы.}
        Для определения таких событий необходимо отдельно хранить начальную позицию каждой вершины.
        То, что вычисления производятся в~системе центра масс, упрощает определение
        отклонения, за~счёт того что постоянные смещения и повороты, не~являющиеся деформациями,
        автоматически исключаются, и отклонение может быть вычислено просто как разность текущей и
        начальной позиции.

        Однако при наличии жёсткой рамы эта разность уже не характеризует деформацию. Рама может
        двигаться относительно центра масс, и её вершины при этом будут иметь ненулевое отклонение
        от начальных позиций. Но на~самом деле форма рамы не~изменилась, так что считать, что событие
        произошло, в~этом случае неверно. Чтобы исключить такие ложные события, необходимо определить смещение и поворот
        рамы в~системе центра масс относительно начального положения. Если перед сравнением позиции
        вершины с~её начальной позицией вычесть это смещение и поворот, то позиции вершин рамы
        всегда будет совпадать с~начальными. Смещение и поворот можно определить, интегрируя на
        каждом шаге линейную и угловую скорость рамы. Но для того, чтобы <<вычесть>> поворот,
        необходимо обратить матрицу поворота (для чего её достаточно транспонировать, так~как она
        ортогональна). Чтобы не делать этого на каждом шаге, можно просто интегрировать угловую
        скорость с~противоположным знаком.

        \paragraph{Вход в~заданную область}
        Класс, представляющий область в~трёхмерном пространстве, реализуется как абстрактный класс
        с~чисто виртуальным методом проверки принадлежности точки этой области. В~библиотеке
        представлены несколько простейших реализаций (сферическая, цилиндрическая область и~др.),
        а~необходимые в~конкретном случае более сложные области пользователь системы может
        реализовать в производном классе.
        
      \subsubsection{Реакция на событие}

        Как уже упоминалось в~п.~\ref{sssec:core}, реакция на~каждый тип события реализуется как
        класс с~чисто виртуальным методом, который пользователь системы переопределяет, наследуясь
        от этого класса, и который будет вызван, когда событие произойдёт. Использование такого
        класса вместо простого указателя на функцию позволяет связать с каждой отдельной реакцией
        как системную информацию о параметрах события, так и произвольные пользовательские данные,
        используемые им в~теле основного метода. В~первом случае информация хранится в приватных
        полях базового класса, во~втором~--- в полях, объявленных пользователем в классе-наследнике.

        С~каждым физическим объектом связан массив указателей на базовый класс реакции каждого типа,
        куда пользователь системы добавляет указатели на экземпляры своих классов реакций. 

      \subsubsection{Поддержка высокополигональных сеток}

        Отображение деформаций низкополигональной физической модели объекта на высокополигональную сетку реализуется
        с~использованием того, что остаточная деформация кластера хранится в~нём в~виде матрицы. Для
        этого необходимо каждую вершину высокополигональной сетки также связать с~одним или
        несколькими кластерами и сохранить её исходную позицию. В~каждом кластере её новая позиция
        рассчитывается аналогично целевым позициям в \eqref{eq:goal_pos}, только вместо матрицы
        $\matx A$ можно использовать её ортогональную компоненту $\matx R$, чтобы сильные
        изменения формы физической модели не отражались на отображаемой сетке.

        Однако вершина высокополигональной сетки обычно содержит некоторые связанные вектора:
        например, нормаль к поверхности в данной точке, требующуюся при расчёте освещения, или
        тангенциальный базис для бамп-мэппинга (англ. {\English bump-mapping}). Их тоже необходимо
        преобразовывать, причём перпендикулярные и параллельные поверхности вектора преобразуются
        по-разному. Параллельный поверхности вектор может быть представлен как разность двух
        принадлежащих касательной плоскости точек, причём если взять их достаточно близкими друг
        к~другу, можно считать, что обе лежат на поверхности, и, следовательно, их разность тоже
        преобразуется, как точки поверхности. Нормаль же преобразуется иначе. Пусть $\vect n$~---
        нормаль, тогда касательная плоскость в~точке $\vect{x}_0$ описывается уравнением
        \[
        \vect{n}^T (\vect x - \vect{x}_0) = 0.
        \]
        Пусть точки касательной плоскости преобразуются матрицей $\matx M$, тогда, учитывая, что
        $\matx{M}^{-1} \matx{M} = \matx{E}$, уравнение плоскости преобразуется к~виду
        \[
          \vect{n}^T \matx{M}^{-1} \matx{M} (\vect x - \vect{x}_0) = 0,
        \]
        что эквивалентно
        \[
           \left( (\matx{M}^{-1})^T \vect{n} \right)^T (\matx{M} \vect x - \matx{M} \vect{x}_0) = 0.
        \]
        Отсюда следует, что $(\matx{M}^{-1})^T \vect{n}$ является нормалью к преобразованной
        матрицей $\matx M$ касательной плоскости. Итак, перпендикулярные поверхности вектора
        преобразуются транспонированной обратной матрицей к матрице, которой преобразуются позиции
        вершин и параллельные поверхности вектора.

        Такие вектора, как нормаль или вектора тангенциального базиса, как правило, должны быть
        нормализованы. Однако описанные выше преобразования векторов не гарантируют сохранения
        нормы. Поэтому, если в~этом есть необходимость, после действия описанного выше преобразования
        они должны быть снова нормализованы в~использующем систему приложении.

    \subsection{Параллельные вычисления}
      \todo{сочинить что-нибудь про task manager...}
      %При~синхронизации параллельно исполняемых участков кода в основном цикле нужно избегать
      %использования блокирующих примитивов синхронизации.

  \section{План-график}

    \begin{center}
      \begin{tabular}{|p{10.3cm}|c|c|}\hline
        Задача                                       & Время         & Срок  \\\hline\hline
        Проработка архитектуры системы, разработка и реализация алгоритма деформаций
        с юнит-тестами для тестирования базовых функций и простым тестовым приложением
        для комплексного тестирования                & (выполнено)   & 31.10 \\\hline
        Реализация интерфейса {\English callback}'ов & (выполнено)   & 15.12 \\\hline
        Реализация отображения низкополигональной
        модели на высокополигональную сетку          & (выполнено)   & 15.01 \\\hline
        Разработка интерактивного приложения для
        тестирования правдоподобности деформаций     & (выполнено)   & 15.01 \\\hline
        Профилирование и оптимизация алгоритма       & 1,5 мес.      & 28.02 \\\hline
        Адаптация алгоритма для параллельных
        вычислений                                   & 1 мес.        & 31.03 \\\hline
      \end{tabular}
    \end{center}

  \section{Оценки за отчёт}

    Руководитель: \underscore{1cm} (из 10). Подпись: \underscore{3cm} (Д.\,А.\,Гладкий)

    \vspace{0.5cm}
    Преподаватель: \underscore{2cm}

  \addcontentsline{toc}{section}{Список литературы}
  \bibliography{../biblio/my}
\end{document}

