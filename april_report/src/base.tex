\documentclass[a4paper, 14pt, titlepage]{extarticle}
  \usepackage{cmap}
  \usepackage{mathtext} % для кириллицы в формулах
  \usepackage[T2A]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage[english,russian]{babel}
  \usepackage{indentfirst}
  \usepackage{cite}
  \usepackage{amsmath} % для \eqref
  \usepackage{color} % пока только для TODO:
  \usepackage[pdftex]{graphicx}
  \graphicspath{{../img/}}
  \frenchspacing

  \DeclareSymbolFont{T2Aletters}{T2A}{cmr}{m}{it} % кириллица в формулах курсивом

  \addto\captionsrussian{
    \renewcommand\contentsname{Содержание}
  }

  \newcommand{\underscore}[1]{\hbox to#1{\hrulefill}}
  \newcommand{\todo}[1]{\textbf{\textcolor{red}{TODO: #1}}}
  \newcommand{\eng}[1]{{\English #1}}

  % вставка картинки: \figure{file}{описание}
  \newcommand{\includefigure}[2]{
    \begin{figure}[!htb]
      \center{\includegraphics{#1}}
      \caption{#2} \label{fig:#1}
    \end{figure}
  }

  \newcommand{\vect}[1]{\vec{#1}} % единое выделение векторов (стрелкой)
  \newcommand{\matx}[1]{\mathbf{#1}} % единое выделение матриц (полужирным)
  \newcommand{\transposed}{\top} % единый знак транспонирования (U+22A4 down tack)

  % поля и размер текста
  \textwidth=17cm
  \oddsidemargin=0pt
  \topmargin=0pt
  \headheight=0pt
  \headsep=0pt
  \textheight=24cm
  \linespread{1.3}

  \renewcommand{\theenumii}{(\asbuk{enumii})}
  \renewcommand{\labelenumii}{\asbuk{enumii})}

  \setcounter{tocdepth}{2} % глубина оглавления

  \bibliographystyle{gost780u}

  \hyphenation{англ} % убрать перенос в этом сокращении

  \author{И.\,А.\,Новиков, кафедра АФТИ ФФ НГУ, гр.\,7305}
  \title{Система моделирования деформаций неупругих тел в реальном времени}

\begin{document}

%----------------------- титульный лист ------------------------

  \thispagestyle{empty}
  \begin {center}
  МИНИСТЕРСТВО ОБРАЗОВАНИЯ И НАУКИ РОССИЙСКОЙ ФЕДЕРАЦИИ

  \vspace{0.3cm}

  Новосибирский государственный университет

  \vspace{0.3cm}

  Физический факультет

  Кафедра автоматизации физико-технических исследований

  \vspace {5cm}

  Апрельский отчёт

  \vspace {1cm}

  Новиков Иван Александрович

  \vspace {0.5cm}

  \textbf{СИСТЕМА МОДЕЛИРОВАНИЯ ДЕФОРМАЦИЙ НЕУПРУГИХ ТЕЛ В РЕАЛЬНОМ ВРЕМЕНИ}

  \vspace {2cm}

  \begin{flushright}

    Научный руководитель

    Д.\,А.\,Гладкий

  \end{flushright}

  \vspace {5cm}

  Новосибирск, 2011~г.
  \end {center}

%------------------------- содержание -------------------------

  \tableofcontents
  \newpage

%-------------------------- введение --------------------------
  \section{Введение}

    Приложения виртуальной реальности становятся чрезвычайно рас\-прос\-тра\-нён\-ны\-ми в~наши~дни.  Два
    основных их типа~--- это компьютерные игры и~обучающие симуляторы (тренажёры). Несмотря на
    различные применения, эти два типа приложений имеют много общего, поскольку в~обоих случаях
    требуется создать иллюзию присутствия у~пользователя. Для~этого необходимо как генерировать
    фотореалистичные изображения, так и правдоподобно моделировать физику взаимодействия объектов
    виртуального мира: их движение, столкновения, деформации и~разрушение.

    Моделирование деформаций объектов является актуальной задачей, поскольку помимо приложений
    виртуальной реальности оно находит применение в~системах автоматизированного проектирования, а~также используется
    при~создании спецэффектов к~фильмам. В зависимости от поставленной задачи применяются различные
    подходы. А~именно, в~системах автоматизированного проектирования требуется
    максимальная точность расчётов, в~то~время как в~фильмах и приложениях виртуальной реальности
    требуется лишь визуальная правдоподобность. При~этом, если расчёты для САПР и~спецэффектов могут
    выполняться длительное время, то в~интерактивных приложениях расчёт одного шага вычислений должен
    происходить не~дольше, чем за~промежуток между кадрами, чтобы обеспечивать плавную анимацию
    и чтобы отсутствовала задержка между воздействием на объект и его деформацией.

    Жёсткое требование быстродействия в приложениях реального времени не~только вынуждает
    использовать упрощённые физические модели деформации тела, менее точные, чем используемые
    в~инженерных расчётах, но и накладывают существенные ограничения на способ представления
    моделируемого объекта. Чаще всего он задаётся дискретным образом: в~виде сетки, решётки или
    несвязанного набора точек, причём время расчётов напрямую (как~правило, линейно
    \cite{mueller-meshless}) зависит от количества точек в таком представлении. Для отображения
    объектов обычно используют высоко детализированные сетки, содержащие вплоть до нескольких
    сотен тысяч и даже миллионов точек. Это значительно превышает максимальное допустимое число точек для~большинства
    алгоритмов \cite{mueller-stable, mueller-meshless, chang-crash} при расчётах в~реальном времени на
    современных настольных компьютерах и компьютерах, используемых в тренажёрах. Из-за этого
    невозможно использовать одно и~то~же представление объекта и для моделирования, и для
    отображения.

  \section{Описание предметной области}\label{sec:domain}

    Существуют различные подходы к~моделированию деформаций в~реальном времени. В простейшем случае
    ограничения на~быстродействие алгоритма обходятся за счёт использования предварительно рассчитанных
    деформированных состояний для~некоторого конечного набора возможных ударов по~объекту, одно из которых
    (или~интерполяция между несколькими ближайшими) выбирается в~зависимости от~того, к~какому
    из~этих ударов ближе всего произошедший. В~этом случае допускается использование достаточно сложных
    для~вычисления алгоритмов, таких~как система масс и~пружин (англ. \eng{mass-spring system})
    с~большим разрешением или~метод конечных элементов (англ. \eng{finite elements method, FEM}).
    Однако, при ударе, отличающемся от~заранее рассчитанного, или в~случае сложной комбинации ударов
    моделируемые деформации будут выглядеть не реалистично \cite[с.~1064]{chang-crash}. Кроме того, значительное время, требуемое
    для предварительных расчётов после каждого изменения объекта, прежде чем он может быть загружен
    в приложение для тестирования, создаёт неудобства при разработке приложения. Поэтому наибольший
    интерес представляют решения, в которых моделирование деформаций происходит во время исполнения.

    Одной из~простейших моделей деформируемого тела является упоминавшаяся выше система масс
    и~пружин, в~которой тело представляется в~виде пространственной (как~правило, регулярной и
    кубической) решётки из~материальных точек, связанных между~собой пружинами, при~изменении длины
    прикладывающими к~своим концам силу согласно закону Гука. Будучи очень простой в~реализации,
    такая модель, тем не менее, имеет определённые недостатки. Она моделирует поведение объекта не
    очень точно, причём оно сильно зависит от формы решётки и расположения пружин в ней \cite[с.~8]{mueller-physmodels}.
    Другим недостатком является то, что возбуждение, приложенное локально, распространяется по
    объекту постепенно, перемещаясь на один шаг решётки за шаг алгоритма \cite[с.~232]{parent-animation}.
    Кроме~того, требуется выполнять дополнительную работу по конвертации представления объекта,
    используемого для его отображения (чаще всего это сетка из треугольников), в~регулярную решётку
    и~подбору значений коэффициента упругости пружин так, чтобы добиться требуемых свойств
    моделируемого материала.

    Принципиально другой подход реализуется в моделях, использующих метод конечных элементов, широко
    используемый в~инженерных расчётах. При таком подходе
    непрерывные характеристики деформируемого тела вычисляются путём интерполяции их~значений
    на~элементах конечного размера. Разумеется, использовать в чистом виде этот метод
    в приложениях реального времени невозможно, поскольку инженерные расчёты производятся в
    течение нескольких часов и даже суток. Однако, существуют модели, предлагающие различные упрощения этих
    методов, которые допускают вычисление в реальном времени, как, например в \cite{mueller-stable}.
    Деформации при этом моделируются намного точнее, чем в случае системы масс и пружин, но даже
    упрощённый алгоритм требует больше времени для вычислений. % TODO циферки

    Отдельно стоят так~называемые геометрические алгоритмы, в~которых напрямую не~моделируются
    физические законы. Как~правило, объект представляется в~виде системы частиц, движение каждой из
    которых сначала интегрируется независимо от~остальных, а~следующим шагом на объект в~целом
    накладываются различные физически мотивированные ограничения (сохранение формы, объёма, импульса
    и~т.п.), обеспечивающие в итоге правдоподобные деформации. Такие методы обладают хорошим
    быстродействием и могут вычисляться параллельно, при этом обладая большей устойчивостью и
    простотой в конфигурации, чем системы масс и пружин. Пример такого метода описывается в \cite{mueller-meshless}.

  \section{Постановка задачи}

    Целью работы является разработка системы моделирования деформаций объектов для применения в
    приложениях виртуальной реальности: в компьютерных играх и обучающих тренажёрах.
    К~системе предъявляются следующие требования.

    Необходимо использовать сетки из треугольников в качестве внутреннего представления, либо
    предоставить возможность конвертации, поскольку в приложениях виртуальной реальности отображаемые объекты
    чаще всего представляются именно в таком формате. Это связано с~тем, что треугольник является
    основным геометрическим примитивом для графических процессоров. % TODO пруф

    Система должна иметь достаточное быстродействие, чтобы обеспечивать моделирование в~реальном
    времени. Чтобы это было возможно даже для~объектов, заданных сеткой с~большим числом вершин,
    должна иметься возможность использовать при~моделировании менее детализированное представление
    объекта, а~отображаемую сетку более высокого разрешения обновлять так, чтобы она повторяла
    рассчитанные деформации. При~этом важно предусмотреть некоторое сглаживание смещений точек
    отображаемого объекта, иначе в~их~движении можно будет проследить форму низко детализированного
    представления.

    Для эффективного использования вычислительной мощности многоядерных центральных процессоров,
    получающих в наши дни всё большее распространение, необходимо, чтобы вычисления могли
    выполняться параллельно.

    Кроме~того, предварительно рассчитанные деформированные состояния не~должны использоваться,
    поскольку, как было объяснено в разделе~\ref{sec:domain}, такой подход негативно сказывается на реалистичности
    моделирования и создаёт неудобства при разработке приложения.

    Наконец, интерфейс, предоставляемый системой, не~должен создавать трудностей при~интеграции
    системы в~приложения виртуальной реальности. Основные критерии, которым необходимо следовать,
    описаны в~\cite{gems-middleware} и~включают, в~частности, конфигурируемые обработку ошибок,
    логирование и~выделение памяти, а также отказ от~прямого доступа к~файловой системе в~пользу
    работы с~буферами в~оперативной памяти.

    Для достижения цели необходимо решить следующие задачи.
    \begin{enumerate}
      \item Разработать и~реализовать алгоритм моделирования в реальном времени деформаций
        не\-у\-пру\-гих тел, содержащих недеформируемые части;
      \item Предоставить интерфейс для~двустороннего взаимодействия с~приложением, в~которое будет
        встроена система, включающий:
        \begin{enumerate}
          \item конвертацию представления объекта, используемого в приложении, во внутреннее представление;
          \item получение извне информации о~столкновениях объекта и~приложенных к~нему силах;
          \item уведомление о произошедших событиях, характеризующих сильные локальные деформации;
          \item обновление отображаемой сетки.
        \end{enumerate}
      \item Предусмотреть в~алгоритме возможность использования параллельных вычислений.
    \end{enumerate}

  \section{Система моделирования деформаций}
    \subsection{Архитектура системы}

      Система реализуется в~виде модуля, который может быть встроен в~приложение виртуальной
      реальности: статической либо динамической библиотеки, написанной на языке C++. Выбор языка
      обоснован компромиссом между быстродействием и удобством разработки и интеграции, которые
      обеспечивает использование объектно-ориентированной парадигмы. Не менее важно, что большинство
      компьютерных игр и~других приложений виртуальной реальности написаны именно на этом языке
      программирования, поэтому требование лёгкости интеграции также влияет на выбор в~пользу C++.

      В~системе выделяются следующие подсистемы.
      \begin{enumerate}
        \item Ядро системы, обеспечивающее собственно моделирование.
        \item Подсистема математических расчётов.
        \item Подсистема журналирования и~обработки ошибок.
      \end{enumerate}

      \subsubsection{Ядро системы}\label{sssec:core}

        Ядро системы реализует класс <<деформируемый физический объект>>. Он инициализируется
        начальной конфигурацией объекта и~предоставляет интерфейс для совершения с~ним следующих действий.
        \begin{enumerate}
          \item Задание недеформируемых частей объекта (при наличии таковых).
          \item Задание приложенных сил и~произошедших столкновений.
          \item Определение реакции на события, происходящие при~деформации объекта.
          \item Моделирование процесса деформаций для~заданного промежутка времени.
          \item Обновление формы отображаемой сетки.
        \end{enumerate}

        Таким образом, для~обеспечения перечисленной функциональности система также реализует следующие классы.
        \begin{enumerate}
          \item Сила, приложенная к~объекту.
          \item Реакция на событие.
          \item Область в~трёхмерном пространстве.
          \item Описатель формата отображаемой сетки.
        \end{enumerate}

      \subsubsection{Подсистема математических расчётов}

        Подсистема математических расчётов реализует необходимые для~расчёта деформаций математические объекты
        и~функции. Их набор зависит от выбранного алгоритма и будет описан далее, в п.~\ref{sssec:math}.

      \subsubsection{Подсистема журналирования и~обработки ошибок}

        Данная подсистема обеспечивает обработку ошибок и~предупреждений, возникающих в~процессе
        работы системы, а~также запись в журнал. В приложении, использующем систему, может
        быть реализована своя политика журналирования и обработки ошибок. Для удобства интеграции
        стандартные действия, выполняемые в ответ на каждое из этих событий, можно переопределить
        в~соответствии с политикой приложения.

      \subsection{Основной алгоритм}\label{ssec:basic_algorithm}

      В разделе~\ref{sec:domain} были рассмотрены различные подходы к моделированию деформаций.
      В~частности, было показано, что системы масс и пружин не обеспечивают требуемого качества
      моделирования и требуют дополнительного преобразования формата объекта, а упрощённый метод конечных элементов
      хоть и моделирует деформации очень реалистично, но имеет значительно худшее быстродействие.
      Геометрические же алгоритмы работают очень быстро, но нужно правильно выбрать используемые в
      них ограничения и подобрать параметры, чтобы моделирование было реалистичным в каждом
      конкретном случае. В данной работе за основу алгоритма моделирования взят геометрический
      алгоритм, предложенный в~\cite{mueller-meshless}. Затем он адаптирован для текущей задачи.

      \subsubsection{Исходный алгоритм}

        \paragraph{Входные данные и результат.} Объект представляется в~виде набора точек,
        сгруппированных в~перекрывающиеся множества, называемые кластерами
        (информация о~связях между вершинами, то~есть об~образуемых ими полигонах, не требуется).
        На~вход алгоритма поступает заданный таким образом объект, а так же информация о~приложенных
        силах. Задаётся величина шага по времени. Результатом выполнения одной итерации алгоритма
        являются позиции точек, задающих объект, в следующий момент времени.

        \paragraph{Общая схема алгоритма.} Скорости и позиции этих точек интегрируются независимо
        друг от друга, для чего используется явная схеме Эйлера. Затем над каждым кластером
        производится операция сопоставления формы: вычисляется новое положение центра масс кластера
        $\vect{x}_{ц.м.}$ и оптимальное линейное преобразование $\matx A$, действие которого
        переводит исходную форму кластера в~наиболее близкую к~текущей форме. В качестве критерия
        оптимальности используется сумма квадратов отклонений текущий позиций точек от начальных. Позиции
        вершин в кластере, подвергнутые оптимальному линейному преобразованию и смещению центра масс
        $\vect{g}_i = \matx{A} (\vect{x}^0_i - \vect{x}^0_{ц.м.}) + \vect{x}_{ц.м.}$,
        называются целевыми позициями. Здесь $\vect{x}^0_i$~--- исходная позиция вершины, а
        $\vect{x}^0_{ц.м.}$~--- исходный центр масс кластера. Для каждой вершины, исходя из величины
        отклонения текущей позиции от~целевой, рассчитывается поправка к~скорости, корректирующая
        это отклонение. Если вершина входит одновременно в~несколько кластеров, то~есть находится
        в~зоне их перекрытия, корректирующие поправки от~каждого из~кластеров усредняются, что
        обеспечивает целостность объекта: за~счёт этого кластеры, обрабатываемые независимо,
        не~отделяются друг от~друга.

        \paragraph{Остаточная деформация.} Для моделирования неупругости остаточная деформация
        каждого кластера сохраняется в~форме линейного преобразования $\matx{S}^{ост}$, то~есть
        матрицы $3 \times 3$. Изначально она единичная, а~изменение происходит, лишь когда мера
        текущей деформации превышает заданную пороговую величину. В~качестве такой меры может быть
        использована $ \|\matx S - \matx E\|_2 $, где $\matx S$~--- симметричная компонента $\matx
        A$, $\matx E$~--- единичная матрица, норма Фробениуса $\|\matx M\|_2 = \sqrt{\sum_{i, j} |m_{ij}|^2}$.
        Симметричная матрица $\matx S$ получается при полярном разложении матрицы $\matx A$:
        \begin{equation}\label{eq:polar_decomposition}
          \matx A = \matx R \matx S,
        \end{equation}
        где $\matx R$~--- ортогональная матрица. Остаточная деформация учитывается затем при
        сопоставлении формы и расчёте целевых позиций. А именно, исходные позиции перед сравнением
        с текущими при сопоставлении формы, преобразуются матрицей $\matx{S}^{ост}$. Таким
        образом, сопоставление происходит не с~исходной, а с деформированной формой. Формула для
        расчёта целевых позиций принимает следующий вид:
        \begin{equation}\label{eq:goal_pos}
          \vect{g}_i = \matx{A} \matx{S}^{ост} (\vect{x}^0_i - \vect{x}^0_{ц.м.}) + \vect{x}_{ц.м.}.
        \end{equation}

      \subsubsection{Предлагаемые изменения в алгоритме}\label{sssec:proposed_changes}

        В~исходный алгоритм вносятся изменения, адаптирующие его к~условиям данной
        задачи. Во-первых, моделирование неупругих тел требует демпфирования возникающих колебаний.
        Во-вторых, система отвечает только за~моделирование деформаций, а глобальное движение и
        определение столкновений рассчитываются отдельно приложением, в~которое встроена система.
        Поэтому расчёт деформаций необходимо производить в~локальных координатах~---
        в~неинерциальной системе отсчёта, связанной с центром масс объекта, в которой он не
        движется и не вращается. Далее для краткости она называется системой центра масс.

        \paragraph{Демпфирование.} Чтобы моделируемое поведение неупругого тела выглядело правдоподобным,
        нужно, чтобы затухали только колебания, а глобальное движение тела сохраняло свои характеристики.
        Для этого используется способ, описанный в~\cite[с.~5]{mueller-position-dynamics}. Сначала выделяется
        движение тела как~целого~--- вычисляются скорость центра масс $\vect{v}_{ц.м.}$ и угловая
        скорость $\vect{\omega}$. Для этого рассчитываются центр масс
        $\vect{x}_{ц.м.}$ и тензор инерции $\matx I$ (матрица $3 \times 3$):
        \begin{eqnarray*}
          \vect{x}_{ц.м.} & = & \frac{\sum_i m_i \vect{x_i}}{\sum_i m_i},\\
          \vect{r}_i      & = & \vect{x}_i - \vect{x}_{ц.м.},\\
          \matx{I}        & = & \sum_i m_i ( |\vect{r}_i|^2 \matx E - \vect{r}_i \vect{r}_i^\transposed),\\
        \end{eqnarray*}
        где $\matx E$~--- единичная матрица $3 \times 3$. Затем вычисляются
        \begin{eqnarray*}
          \vect{v}_{ц.м.} & = & \frac{\sum_i m_i \vect{v_i}}{\sum_i m_i},\\
          \vect{L}        & = & \sum_i \vect{r}_i \times (m_i \vect{v}_i),\\
          \vect{\omega}   & = & \matx{I}^{-1} \vect{L}.
        \end{eqnarray*}
        Для каждой вершины определяется скорость,
        которую она имела~бы, если~бы тело было абсолютно твёрдым:
        \begin{equation}\label{eq:rigid_velocity}
          \vect{u}_i = v_{ц.м.} + \omega \times (\vect{x}_i - \vect{x}_{ц.м.}).
        \end{equation}
        Демпфированию подвергается только индивидуальное отклонение скорости вершины
        $\Delta \vect{v}_i = \vect{v}_i - \vect{u}_i$:
        \begin{equation}\label{eq:damping}
          \vect{v}_i = \vect{v}_i - k \Delta \vect{v}_i,
        \end{equation}
        где $k \in [0, 1]$. За счёт этого $\vect{v}_{ц.м.}$ и $\vect{\omega}$ сохраняются.

        \paragraph{Расчёт в локальных координатах.} Проблема, возникающая при расчёте деформаций в
        системе центра масс, заключается в том, что вследствие удара или воздействия внешних сил
        у~тела может появиться как ненулевая скорость центра масс, так и ненулевая угловая скорость.
        Таким образом, система отсчёта, в~которой производится расчёт, перестанет быть системой центра
        масс. Поэтому после интегрирования скоростей и до интегрирования позиций вершин производится
        коррекция. Приобретённые на данном шаге $\vect{v}_{ц.м.}$ и $\vect{\omega}$ уже получены
        в~ходе расчёта демпфирования. Чтобы локальная система отсчёта снова стала системой центра масс,
        необходимо скомпенсировать их, вычитая из скорости каждой вершины $\vect{u}_i$ из \eqref{eq:rigid_velocity}.
        После этого приложение, в которое встроена система, должно получить из неё значения
        $\vect{v}_{ц.м.}$ и $\vect{\omega}$ и скорректировать глобальное движение объекта, прибавив их
        к его линейной и угловой скоростям соответственно.

    \subsection{Реализация дополнительных функций}

      Как уже говорилось в п.~\ref{sssec:core}, кроме собственно моделирования деформаций, ядро
      системы предоставляет дополнительную функциональность, а именно, поддержку недеформируемых
      частей, получение информации о произошедших столкновениях и приложенных силах, определение
      реакции на определённые события и обновление отображаемой сетки. Предлагаемые способы
      реализации этих функций описаны далее.

      \subsubsection{Поддержка недеформируемых частей}

        Система позволяет задать множество вершин, сохраняющее свою форму~--- недеформируемую раму.
        Чтобы обеспечить это, используется та~же техника, что и в~алгоритме демпфирования,
        описанном в п.~\ref{sssec:proposed_changes}, только коэффициент $k$ в~\eqref{eq:damping}
        берётся равным единице, то~есть индивидуальные отклонения скоростей $\Delta \vect{v}_i$
        подавляются полностью. Это действие необходимо также производить на каждом шаге, после
        интегрирования скоростей, но до~демпфирования, иначе из-за порождённых колебаний система
        может стать нестабильной.

      \subsubsection{Получение информации о внешних воздействиях}\label{sssec:external_forces}

        Деформация объекта происходит по причине внешних воздействий на него, наиболее интересными
        из которых являются столкновения~--- они и приводят к наибольшим деформациям. Количественно
        столкновение может быть задано как~в виде силы, действующей в~течение определённого времени, так и
        в~виде мгновенно сообщаемого объекту изменения импульса.
        Система поддерживает оба формата, что позволяет интегрировать её в приложение независимо от
        того, какой способ задания столкновений в~нём используется.

        Любое внешнее воздействие оказывается локально, поэтому необходимо также указать область,
        в~которой оно действует. Класс, представляющий область в~трёхмерном пространстве,
        реализуется как абстрактный класс с~чисто виртуальным методом проверки принадлежности точки
        этой области. В~библиотеке представлены несколько простейших реализаций (сферическая,
        цилиндрическая область и~др.), а~необходимые в~конкретном случае более сложные области
        пользователь системы может реализовать в производном классе.

      \subsubsection{Обнаружение произошедших событий}\label{sssec:events}

        Система может обнаружить следующие виды событий.
        \begin{enumerate}
          \item Удар в~заданною область, превышающий по~силе заданный порог;
          \item Отклонение некоторой точки объекта от~начальной формы больше заданного предела;
          \item Вход некоторой точки в~заданную область (или выход из~неё).
        \end{enumerate}
        Способ обнаружения каждого из событий описан далее.

        \paragraph{Удар в заданную область.}
        Простейшее событие~--- это удар в некоторую область, заданную массивом индексов
        входящих в~неё вершин. Для его определения нужно лишь проверить, входит ли хоть одна из этих
        вершин в~зону действия удара и превышает~ли изменение её скорости пороговую величину.

        \paragraph{Отклонение от начальной формы.}
        Для определения таких событий необходимо отдельно хранить начальную позицию каждой вершины.
        То, что вычисления производятся в~системе центра масс, упрощает определение
        отклонения. За~счёт того что постоянные смещения и повороты, не~являющиеся деформациями,
        автоматически исключаются, отклонение может быть вычислено просто как разность текущей и
        начальной позиции.

        Однако при наличии жёсткой рамы эта разность уже не характеризует деформацию. Рама может
        двигаться относительно центра масс, и её вершины при этом будут иметь ненулевое отклонение
        от начальных позиций. Но на~самом деле форма рамы не~изменилась, так что считать, что событие
        произошло, в~этом случае неверно. Чтобы исключить такие ложные события, необходимо определить смещение и поворот
        рамы в~системе центра масс относительно начального положения. Если перед сравнением позиции
        вершины с~её начальной позицией вычесть это смещение и поворот, то позиции вершин рамы
        всегда будет совпадать с~начальными. Смещение и поворот можно определить, интегрируя на
        каждом шаге линейную и угловую скорость рамы. Но для того, чтобы <<вычесть>> поворот,
        необходимо обратить матрицу поворота (для чего её достаточно транспонировать, так~как она
        ортогональна). Чтобы не делать этого на каждом шаге, можно просто интегрировать угловую
        скорость с~противоположным знаком.

        \paragraph{Вход в~заданную область.}
        Способ задания области в~трёхмерном пространстве был описан выше в п.~\ref{sssec:external_forces}.
        Координаты, в которых задана область, логично связать с~неподвижной рамой. Для этого, как и
        в~случае с определением отклонения от начальной формы, перед проверкой на принадлежность
        области необходимо подвергнуть позицию вершины смещению и повороту, обратным к смещению и
        повороту рамы.

      \subsubsection{Реакция на событие}

        Реакция на~каждый тип события реализуется как класс с~чисто виртуальным методом, который
        пользователь системы определяет в~своём производном классе. Этот метод будет вызван, когда
        событие произойдёт. Использование такого класса вместо простого указателя на функцию
        позволяет связать с каждой отдельной реакцией как системную информацию о параметрах события,
        так и произвольные пользовательские данные, используемые в~теле основного метода. В~первом
        случае информация хранится в приватных полях базового класса, во~втором~--- в~полях,
        объявленных пользователем в производном классе.

        С~каждым физическим объектом связан массив указателей на базовый класс реакции каждого типа,
        куда пользователь системы добавляет указатели на экземпляры своих классов реакций.

      \subsubsection{Поддержка высокополигональных сеток}\label{sssec:hi-poly}

        \paragraph{Преобразование позиций.}
        Отображение деформаций низкополигональной физической модели объекта на высокополигональную
        отображаемую сетку реализуется с~использованием того, что остаточная деформация кластера и
        его текущее состояние хранятся в~нём в~виде матриц.  Для этого необходимо каждую вершину
        высокополигональной сетки также связать с~одним или несколькими кластерами и сохранить её
        исходную позицию. В~каждом кластере её новая позиция рассчитывается аналогично целевым
        позициям в \eqref{eq:goal_pos}. Здесь вместо матрицы оптимального линейного преобразования
        $\matx A$ можно использовать её ортогональную компоненту $\matx R$, характеризующую
        оптимальное вращение, чтобы сильные изменения формы физической модели не отражались на
        отображаемой сетке:
        \begin{equation}\label{eq:graphical_pos}
          \vect{x}'_i = \matx{R} \matx{S}^{ост} (\vect{x}^0_i - \vect{x}^0_{ц.м.}) + \vect{x}_{ц.м.}.
        \end{equation}
        В случае, если вершина входит в несколько кластеров, позиции, рассчитанные по этой формуле
        для каждого из них, должны быть усреднены. Полученная в результате позиция и будет позицией
        вершины в деформированной отображаемой сетке.

        \paragraph{Преобразование векторов.}
        Кроме позиции вершина высокополигональной сетки обычно также содержит некоторые связанные векторы:
        например, нормаль к поверхности в данной точке, требующуюся при расчёте освещения, или
        тангенциальный базис для бамп-мэппинга (англ. \eng{bump-mapping}). Их тоже необходимо
        преобразовывать, причём векторы, параллельные поверхности, преобразуются не так, как
        перпендикулярные ей. Параллельный поверхности вектор может быть представлен как разность двух
        принадлежащих касательной плоскости точек, причём если взять их достаточно близкими друг
        к~другу, можно считать, что они обе лежат на поверхности, и, следовательно, их разность
        преобразуется так же, как и точки поверхности. Нормаль же преобразуется иначе. Пусть $\vect n$~---
        нормаль, тогда касательная плоскость в~точке $\vect{x}_0$ описывается уравнением
        \[
        \vect{n}^\transposed (\vect x - \vect{x}_0) = 0.
        \]
        Пусть точки касательной плоскости преобразуются матрицей $\matx M$, тогда, учитывая, что
        $\matx{M}^{-1} \matx{M} = \matx{E}$, уравнение плоскости преобразуется к~виду
        \[
          \vect{n}^\transposed \matx{M}^{-1} \matx{M} (\vect x - \vect{x}_0) = 0,
        \]
        что эквивалентно
        \[
           \left( (\matx{M}^{-1})^\transposed \vect{n} \right)^\transposed (\matx{M} \vect x - \matx{M} \vect{x}_0) = 0.
        \]
        Отсюда следует, что $(\matx{M}^{-1})^\transposed \vect{n}$ является нормалью к преобразованной
        матрицей $\matx M$ касательной плоскости. Итак, перпендикулярные поверхности векторы
        преобразуются транспонированной обратной матрицей к матрице, которой преобразуются позиции
        вершин и векторы, параллельные поверхности.

        \paragraph{Необходимость коррекции векторов.}
        Такие векторы, как нормаль или векторы тангенциального базиса, как правило, должны быть
        нормализованы. Однако описанные выше преобразования векторов не гарантируют сохранения
        нормы. Поэтому, если в~этом есть необходимость, после действия описанного выше преобразования
        они должны быть снова нормализованы в~использующем систему приложении.

        \paragraph{Поддержка произвольного формата вершины.}
        Для упрощения интеграции система должна накладывать минимальные ограничения на формат
        вершины в~отображаемой сетке. Поэтому формат не является фиксированным, для его задания
        используется специальный объект <<описатель вершины>>. Пользователь системы создаёт этот
        объект, указывая в~нём размер в~байтах структуры, задающей вершину, и расположение в~ней
        (в~виде смещения от начала структуры в~байтах) полей, хранящих связанные с~вершиной точки и
        векторы, в~том числе, её позицию.  Предполагается, что каждая точка или вектор хранятся
        в~этой структуре как три последовательных числа с~плавающей точкой одинарной точности (тип
        \eng{float} в~C++)~--- такой способ задания является наиболее распространённым в~популярных
        библиотеках трёхмерной графики \eng{DirectX} и \eng{OpenGL}. Этих точек и %TODO Пруф
        векторов может быть несколько, поэтому в~описателе вершины хранится массив их смещений,
        кроме того, в отдельном массиве для каждого вектора хранится булевский флаг, задающий,
        является~ли этот вектор параллельным или перпендикулярным поверхности. Указатель на~массив
        вершин отображаемой сетки передаётся как указатель на неопределённый тип (void*)
        в~конструктор класса, представляющего деформируемый объект, где требуется информация о
        начальных позициях вершин для сохранения и привязки вершин к кластерам, и в~функцию
        обновления отображаемой сетки. В~обоих случаях вместе с~указателем на массив вершин
        передаётся описатель вершины, который используется для индексирования этого массива и
        доступа к~хранящимся в~вершине данным.

    \subsection{Параллельные вычисления}

      Чтобы вычисления могли выполняться параллельно, необходимо разбить алгоритм на независимые
      блоки, называемые задачами, реализовать класс, отвечающий за выполнение задачи каждого типа, и
      менеджер задач, обеспечивающий их параллельное выполнение. Кроме того, часть вычислений по
      обработке отображаемой сетки может быть перенесена на графический процессор.

      \subsubsection{Разбиение алгоритма на задачи}

        Основной алгоритм содержит два основных этапа, состоящих из независимых однотипных блоков
        действий. Первый~--- выполнение операции сопоставления формы для каждого кластера,
        второй~--- интегрирование скоростей для каждой вершины. Таким образом, сопоставление формы
        можно выделить в~качестве независимой задачи. Выделять обработку одной вершины как отдельную задачу
        бессмысленно, поскольку при этом получится большое количество коротких задач, так что
        затраты на переключение задач могут снизить или даже полностью исключить выигрыш от
        параллельного выполнения. Разумнее будет группировать вершины, выделяя в~качестве задачи,
        например, обработку всех вершин одного кластера.

      \subsubsection{Реализация задач}

        Базовый класс, представляющий задачу, содержит чисто виртуальный метод выполнения задачи,
        а~также булевский флаг готовности. В~данном случае задачи второго этапа не~могут выполнены,
        пока не выполнены соответствующие задачи первого этапа. Нельзя интегрировать скорости
        вершины до того, как в~ходе операции сопоставления формы будут вычислены поправки к~её
        скорости от всех кластеров, в~которые она входит. Таким образом, появляется понятие
        зависимости между задачами. В~каждой задаче должен также храниться массив указателей на
        задачи, от которых она зависит, и перед началом выполнения нужно убедиться, что все они
        выполнены.

        Использование каких-либо определённых примитивов синхронизации может ухудшить переносимость
        системы. Необходимо предоставить возможность для замены используемого набора примитивов.
        Например, использовать абстрактный класс, различные реализации которого будут
        соответствовать разным наборам примитивов синхронизации. Впрочем, необходимо
        с осторожностью использовать блокирующие примитивы синхронизации, поскольку их неправильное
        использование может привести к~тому, что ожидающие друг друга задачи будут выполняться
        последовательно, а не параллельно.

      \subsubsection{Менеджер задач}

        Ключевой момент при реализации менеджера задач в данном случае~--- то, что в~приложении,
        использующем систему, может быть собственный менеджер задач. В этом случае более эффективно
        будет использовать его возможности по распределению задач по потокам, чем реализовывать
        собственный пул потоков (англ. \eng{thread pool})\cite{concurrent-patterns}. Кроме того,
        исключая зависимость от конкретной библиотеки для управления потоками, можно улучшить
        переносимость системы. Таким образом, система должна лишь предоставлять очередь задач,
        вынимать и выполнять задачи из которой будет менеджер задач приложения.

      \subsubsection{Использование графического процессора}

        \paragraph{Возможности графического процессора.}
        Процесс создания изображения графическим процессором представляет собой конвейер,
        осуществляющий параллельную обработку данных на каждом этапе: отдельных вершин,
        геометрических примитивов и, в~итоге, пикселов отображаемого на экране двумерного
        изображения. За обработку на каждом этапе отвечает короткая программа~--- шейдер,
        применяемая к~каждому обрабатываемому объекту в~отдельности: вершине, примитиву или пикселу.
        Кроме данных текущего объекта шейдер имеет доступ к~данным, одинаковым для всех объектов
        данного этапа~--- константам шейдера.

        \paragraph{Выбор подходящей задачи.}
        В~связи с~перечисленными выше особенностями шейдеров, не всякая задача может быть выполнена
        на графическом процессоре. В~данной работе наиболее подходящей для этого является задача
        вычисления новых позиций вершин отображаемой сетки в~результате деформации. Во-первых, один
        из этапов графического конвейера отвечает именно за обработку вершин. Во-вторых, согласно
        формуле~\eqref{eq:graphical_pos}, для вычисления позиции каждой вершины требуется только её
        начальная позиция и параметры кластеров, одинаковые для всех вершин, то есть только те
        данные, которые доступны в~вершинном шейдере. Наконец, при вычислении используются только
        арифметические операции над векторами и умножение матрицы на вектор, которое может быть
        представлено как последовательные скалярные произведения. Все эти операции присутствуют
        в~наборе инструкций графического процессора.

        \paragraph{Реализация вычислений в вершинном шейдере.}
        Таким образом, вычисление $\vect{x}'_i$ по формуле~\eqref{eq:graphical_pos} и последующее
        усреднение (в случае нескольких кластеров) может быть выполнено в~вершинном шейдере, если
        необходимые параметры всех кластеров: исходный и текущий центр масс и матрица $\matx D =
        \matx{R} \matx{S}^{ост}$~--- будут переданы в~качестве констант шейдера. Поскольку каждая
        вершина может входить в~несколько кластеров, с~ней необходимо связать число кластеров,
        в~которые она входит, и их индексы в~массиве кластеров. Эти величины должны быть заданы для
        каждой вершины в~процессе инициализации объекта. При этом в~основном цикле уже не требуется
        производить запись в~буфер отображаемых вершин, необходимо лишь записывать новые значения
        параметров кластеров в соответствующие константы шейдера. Поэтому в~данном случае описатель
        вершины несёт другую функцию, нежели при вычислении на центральном процессоре: вместо
        расположения в~структуре всех точек и векторов, требующих обновления, он теперь должен
        хранить лишь расположение следующих величин: позиции (требуется для определения
        принадлежности кластерам), числа кластеров и их индексов (будут записаны единожды в
        конструкторе объекта).

    \subsection{Объектно-ориентированная модель}

      В этом подразделе описывается объектно-ориентированная модель системы: классы, их методы и
      связи друг с другом. Все классы системы объявляются внутри собственного пространства имён во
      избежание конфликтов с одноимёнными классами в приложении, использующем систему.

      \subsubsection{Подсистема журналирования и обработки ошибок}
        \includefigure{logging}{структура подсистемы журналирования и обработки ошибок.}

        Основной класс этой подсистемы, Logger, реализует шаблон проектирования <<Одиночка>> (англ.
        \eng{singleton}), что обеспечивает работу с одним и тем же объектом по всей системе без
        необходимости передачи его по всей цепочке вызовов. Чисто виртуальный класс Action
        используется для задания действия, выполняемого в ответ на то или иное событие (запись в
        журнал, предупреждение, ошибка). В подсистеме представлены простейшие реализации действий по
        умолчанию, пользователь же может определить своё действие в~классе, производном от Action. Класс
        Logger содержит следующие методы.
        \begin{enumerate}
          \item Определение действия для конкретного события: метод set\_action.
          \item Отключение реакции на конкретное событие: метод ignore.
          \item Вызов действия: метод invoke.
        \end{enumerate}

      \subsubsection{Подсистема математических расчётов}\label{sssec:math}

        Для функционирования основного алгоритма, описанного в подразделе \ref{ssec:basic_algorithm}, требуются
        функции векторной и матричной алгебры. Для этого подсистема математических расчётов содержит
        классы Vector и Matrix, реализующие стандартный набор алгебраических операций. Нетривиальные
        функции описаны ниже.

        \paragraph{Обращение матрицы.}
        Обратная матрица находится как транспонированная матрица алгебраических дополнений, делённая
        на определитель исходной матрицы. Этот метод больше подходит для программной реализации, чем
        метод Гаусса-Жордана, поскольку представляет собой простую формулу, а не итеративный
        алгоритм.

        \paragraph{Диагонализация матрицы.}
        Приведение матрицы к диагональному виду осуществляется методом вращений Якоби (англ.
        \eng{Jacobi rotation})~--- быстрым приближенным итеративным методом \cite{fortran-jacobi}.

        \paragraph{Вычисление функции от матрицы.}
        Для вычисления функции от матрицы она диагонализуется, после чего функция применяется к
        диагональным элементам и матрица преобразуется обратно в исходный базис.

        \paragraph{Полярное разложение.}
        Полярное разложение матрицы $\matx M$ на ортогональную $\matx R$ и симметричную $\matx S$ компоненты
        $\matx M = \matx R \matx S$ осуществляется следующим образом:
        \begin{eqnarray*}
          \matx S & = & \sqrt{\matx{M}^\transposed \matx{M}},\\
          \matx R & = & \matx M \matx{S}^{-1}.
        \end{eqnarray*}
        Здесь используется описанная выше функция вычисления функции от матрицы: в качестве функции
        выступает квадратный корень.

      \subsubsection{Ядро системы}

        Основным классом подсистемы является Model, физическая модель деформируемого объекта.
        Физическая конфигурация (форма и распределение массы) и отображаемая форма описываются
        массивами вершин соответствующих классов: PhysicalVertex и GraphicalVertex. Оба вида вершин
        группируются в~кластеры, за что отвечает класс Cluster. Как уже говорилось в
        п.~\ref{sssec:hi-poly}, описатель вершины, объект класса VertexInfo, используется для
        конвертации вершин из формата, используемого в~приложении, во внутренний формат и обратно.

        \includefigure{core-vertices}{представление моделируемого объекта в системе.}

        Информация о~внешних воздействиях может быть сообщена объекту двумя способами. Во-первых,
        функция Model::hit мгновенно изменяет скорость вершин, входящих в~заданную область. Область
        задаётся объектом класса, производного IRegion, в~котором определён метод contains,
        возвращающий true, если данная точка принадлежит области. Другой способ~--- передать массив указателей
        на экземпляры классов-наследников Force, описывающих приложенные к объекту силы, в~функцию
        Model::compute\_next\_step, выполняющую вычисление очередного шага алгоритма. Действие этих
        сил будет учтено при интегрировании скоростей. Для создания собственной реализации силы,
        необходимо в~классе, производном от Force определить метод is\_applied\_to, определяющий,
        приложена ли сила к~вершине, находящейся в данной точке, и метод get\_value\_at,
        возвращающий вектор силы в этой точке.

        \includefigure{core-interaction}{получение информации о внешних воздействиях.}

        Как уже упоминалось в п.~\ref{sssec:proposed_changes} и п.~\ref{sssec:events}, в~процессе
        моделирования возникает необходимость в~определении усреднённых линейной и угловой скоростей
        объекта и рамы и в последующем интегрировании этих скоростей. Первую задачу решает класс
        DiscreteBody, вторую~--- RigidBody. Класс DiscreteBody также отвечает за демпфирование колебаний
        объекта и обеспечение движения рамы как твёрдого тела. Он позволяет привести скорости всех
        входящих в него вершин к вычисленным усреднённым величинам (с~некоторым коэффициентом или в
        точности). В~свою очередь, RigidBody позволяет интегрировать движение, обратное
        к движению жёсткой рамы. Получаемая при этом матрица поворота используется в процессе
        обнаружения отклонения вершины от начальной позиции.

        \includefigure{core-bodies}{расчёт и интегрирование характеристик объекта как целого.}

        Реакции на три вида поддерживаемых событий: удар в~заданное множество вершин, отклонение от
        начальной формы и вход в~заданную область~--- определяются в~методе invoke класса,
        производного, от одного из базовых: HitReaction, ShapeDeformationReaction или RegionReaction
        соответственно. Каждый из этих классов содержит параметры отслеживаемого события, которые
        необходимо передать в~его конструктор. Для HitReaction это пороговая абсолютная величина
        изменения скорости вершины при ударе и множество вершин, заданное набором индексов вершин
        в~массиве, в котором они были переданы в~конструктор объекта. Параметрами для
        реакции на изменение формы являются множество вершин, заданное аналогичным образом, и минимальное
        отклонение позиции вершины от начальной позиции, при котором событие считается произошедшим.
        RegionReaction хранит в себе указатель на IRegion, также при создании можно указать, что
        является событием: вход в заданную этим указателем область или выход из неё.

        \includefigure{core-reactions}{определение реакции на события.}

        \paragraph{Использование.}
        Таким образом, типичный сценарий работы с~классом Model следующий. Инициализация:
        \begin{enumerate}
          \item Создание экземпляра: в конструктор передаются исходные массивы физических и
          отображаемых вершин, их описатели (VertexInfo), а также параметры разбиения на кластеры:
          количество и степень перекрытия.
          \item Задание недеформируемой рамы: метод set\_frame.
          \item Определение реакций на события: методы add\_hit\_reaction,\\
          add\_shape\_deformation\_reaction и add\_region\_reaction\\
          (не были показаны на диаграммах для краткости).
        \end{enumerate}
        В теле основного цикла:
        \begin{enumerate}
          \item Сообщение об ударе: метод hit.
          \item Расчёт шага алгоритма: метод compute\_next\_step.
          \item Обновление отображаемой сетки: метод update\_vertices.
        \end{enumerate}

    \subsection{Тестирование}

      Корректность работы системы тестируется на двух уровнях: на уровне отдельных функций и на
      уровне системы в~целом. Для тестирования отдельной функции применяется юнит-тестирование:
      пишется несколько тестов, проверяющих корректность её работы в~характерных случаях. Таким
      образом удобно тестировать все функции подсистемы математических расчётов и подсистемы
      журналирования и обработки ошибок, функции доступа к~полям классов, обработку некорректных
      аргументов, расчёт таких предсказуемых величин, как центр масс кластера или
      момент инерции объекта. Преимуществами юнит-тестирования являются лёгкость локализации ошибки
      (за счёт того, что сразу известно, какая функция работает некорректно) и возможность
      убедиться, что система по-прежнему работоспособна после внесения изменений, в~том числе
      после рефакторинга или оптимизации. В~то же время, не менее важно тестировать правдоподобность
      моделируемых деформаций. Но сформулировать математический критерий правдоподобности сложно,
      поэтому юнит-тесты плохо подходят для такого тестирования. Чтобы оно могло осуществляться
      человеком, разработано простое интерактивное приложение, позволяющее пользователю подвергать
      тестовый объект различным воздействиям и наблюдать изменения, происходящие при этом с
      трёхмерной моделью объекта.

  \section{Результаты}

    Система моделирования деформаций была реализована в~виде модуля, а именно, статической
    библиотеки. Было разработано тестовое приложение, использующее эту библиотеку, которое
    средствами DirectX 9 отображает трёхмерную модель объекта и позволяет деформировать его,
    нанося удары с~разных сторон. Для проверки правдоподобности деформаций и измерения
    производительности были созданы два тестовых объекта, с~простой и с~более сложной геометрией.
    Они рассмотрены в~последующих подразделах.

    \subsection{Цилиндр}

      \todo{картинка.} В качестве объекта с простой геометрией используется цилиндр, содержащий
      2400 точек в физической модели и 20000 вершин (13500 полигонов) в отображаемой сетке.

      Были протестированы следующие случаи воздействий на объект.
      \begin{enumerate}
        \item Удар такой-то. Результат такой-то, см. рис.~такой-то.
        \item Удар такой-то. Результат такой-то, см. рис.~такой-то.
        \item Удар такой-то. Результат такой-то, см. рис.~такой-то.
      \end{enumerate}

      Также было проведено исследование зависимости времени расчётов от числа вершин в физической
      модели и отображаемой сетке. Для каждого числа вершин производилось 5 запусков тестового
      приложения, каждый из которых длился 1 минуту. Объекту сообщались одинаковые удары. Во время
      исполнения на каждом кадре измерялось время, требуемое для физического моделирования и для
      вычисления позиций вершин отображаемой сетки. По получаемой выборке рассчитывались
      минимальное, среднее и максимальное значение. Многократные запуски необходимы, чтобы исключить
      факторы, внешние по отношению к~приложению, например, загрузку процессора другими приложениями
      и операционной системой. Приложение запускалось на компьютере со следующими характеристиками:
      Двухъядерный процессор Intel Core 2 Duo, тактовая частота 2.5 ГГц, видеоадаптер NVIDIA GeForce
      8800 GT.

      \todo{таблица 1: зависимость от числа вершин в физической модели}

      \todo{график 1: зависимость от числа вершин в физической модели}

      \todo{таблица 2: зависимость от числа вершин в отображаемой сетке}

      \todo{график 2: зависимость от числа вершин в отображаемой сетке}

      \paragraph{Выводы.} Зависимость от числа вершин обоих типов линейная, но затраты времени на
      одну вершину физической модели значительно выше затрат на одну отображаемую вершину.  Таким
      образом, использование физической модели с~меньшим числом вершин и последующее отображение
      её деформаций на отображаемую сетку с~б\'{о}льшим числом вершин оправдано.

    \subsection{Автомобиль}

      \todo{картинка.} В качестве объекта со сложной геометрией используется автомобиль, содержащий
      10000 точек в физической модели и 100000 вершин (67500 полигонов) в отображаемой сетке.

      Были протестированы следующие случаи воздействий на объект.
      \begin{enumerate}
        \item Удар такой-то. Результат такой-то, см. рис.~такой-то.
        \item Удар такой-то. Результат такой-то, см. рис.~такой-то.
        \item Удар такой-то. Результат такой-то, см. рис.~такой-то.
      \end{enumerate}

      Запуск тестового интерактивного приложения и замеры производительности системы
      производились на компьютерах с~разным числом ядер процессора, чтобы проверить масштабируемость
      многопоточного алгоритма. Использовались компьютеры со следующими характеристиками:
      \begin{enumerate}
        \item Одноядерный процессор Intel Pentium~4, тактовая частота 2 ГГц, видеоадаптер ATI Radeon HD 9800.
        \item Двухъядерный процессор Intel Core 2 Duo, тактовая частота 2.5 ГГц, видеоадаптер NVIDIA GeForce 8800 GT.
        \item Четырёхъядерный процессор Intel Core i5, тактовая частота 2.8 ГГц, видеоадаптер NVIDIA GeForce GTX 280.
      \end{enumerate}

      Так как время исполнения обратно пропорционально тактовой частоте процессора, для выявления
      зависимости от числа ядер необходимо исключить зависимость от скорости исполнения. Для этого
      измеренное время умножается на тактовую частоту, полученная величина характеризует примерное
      число тактов, необходимое для выполнения расчёта, независимо от скорости процессора.

      \todo{таблица 3: зависимость от количества ядер процессора}

      \todo{график 3: зависимость от количества ядер процессора}

  \section{Выводы}

    \todo{написать}

  \section{Дальнейшая работа}

    \todo{написать}

  \section{План-график}

    \begin{center}
      \begin{tabular}{|p{10.3cm}|c|c|}\hline
        Задача                                       & Время         & Срок  \\\hline\hline
        Проработка архитектуры системы, разработка и реализация алгоритма деформаций
        с юнит-тестами для тестирования базовых функций и простым тестовым приложением
        для комплексного тестирования                & (выполнено)   & 31.10 \\\hline
        Обнаружение событий и реакция на них         & (выполнено)   & 15.12 \\\hline
        Реализация отображения низкополигональной
        модели на высокополигональную сетку          & (выполнено)   & 15.01 \\\hline
        Разработка интерактивного приложения для
        тестирования правдоподобности деформаций     & (выполнено)   & 15.01 \\\hline
        Профилирование и оптимизация алгоритма       & (выполнено)   & 15.03 \\\hline
        Адаптация алгоритма для параллельных
        вычислений                                   & 1 мес.        & 15.04 \\\hline
      \end{tabular}
    \end{center}

  \section{Оценки за отчёт}

    Руководитель: \underscore{1cm} (из 10). Подпись: \underscore{3cm} (Д.\,А.\,Гладкий)

    \vspace{0.5cm}
    Преподаватель: \underscore{2cm}

  \addcontentsline{toc}{section}{Список литературы}

  \begin{flushleft}
    \bibliography{../biblio/my}
  \end{flushleft}
\end{document}

